{"version":3,"sources":["components/Theory.js","components/Grid.js","algorithms/AStar.js","algorithms/GreedyBestFirst.js","algorithms/Djikstra.js","algorithms/BFS.js","components/InfoBar.js","components/Grids.js","components/Traversal.js","App.js","serviceWorker.js","index.js"],"names":["Theory","Container","Row","Col","Grid","props","this","isWallGrid","isStartGrid","isEndGrid","id","row","col","className","getAdditionalGridProps","onMouseDown","onMouseUp","onMouseEnter","onMouseLeave","Component","initialGrid","originalGrid","isVisited","previousGrid","fValue","gValue","hValue","astar","allGrids","astarImplementation","initialGrids","startGrid","endGrid","length","currentRow","modifiedGrid","push","initializeGrids","visitedGridsInOrder","openList","closedList","lowestFOrH","i","currentGrid","getShortestPath","indexCurrentGrid","indexOf","splice","neighbors","getNeighborsOfGrid","neighbor","currentG","isBestG","isPartOfArray","Math","abs","shortestPath","unshift","grid","neighborDown","filter","gridsList","some","item","greedyBestFirst","greedyBestFirstImplementation","lowestH","console","log","distance","Infinity","djikstra","djikstraImplementation","totalGrids","allNodes","grids","getAllGrids","sortGridsByDistance","shift","relaxDistance","sort","A","B","neighborRight","neighborLeft","map","updateNeighborsProperties","bfs","bfsImplementation","queue","updateNeighborsAndQueue","InfoBar","class","Badge","algoChoices","Grids","header","htmlFor","value","state","algo","onChange","e","setState","target","key","Button","onClick","visualizeAlgo","disabled","buttonsEnabled","rowSize","colSize","startRow","startCol","endRow","endCol","mousePressed","buttonDragged","pureGrid","handleMouseDown","bind","handleMouseEnter","handleMouseUp","handleMouseLeave","setInitialGrids","prevState","newGrids","slice","oldGrid","newGrid","Object","assign","resetColor","toggleWallGrid","toggleStartEndPosition","document","getElementById","toggleButtonsEnabled","shortestPathGrids","index","setTimeout","visualizePath","setStartEndGridClassName","gridsRow","rowIndex","gridsCol","colIndex","Traversal","App","type","data-toggle","data-target","aria-controls","aria-expanded","aria-label","Nav","Link","as","NavLink","exact","to","activeStyle","fontWeight","color","path","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.5b689a36.chunk.js","sourcesContent":["import React from \"react\";\nimport { Row, Col, Container } from \"react-bootstrap\";\nimport \"./Theory.css\";\n\nexport function Theory() {\n  return (\n    <Container>\n      <Row>\n        <Col>\n          <h6>\n            The result given in the visualizer is the best prediction of the\n            time complexity of the algorithm given. What is time complexity?\n          </h6>\n          The time complexity (rate-of-growth) is the growth of time consumed by the algorithm as\n          the input size grows.\n          <h6>\n            What is input size? <br />\n          </h6>\n          Input size is, informally, the variable which affects the number of\n          times the code is run. For example, look at this piece of code\n          <br />\n          <code>\n            def f(x, n):\n            <br />\n            &nbsp;&nbsp;for i in range(n):\n            <br />\n            &nbsp;&nbsp;&nbsp;&nbsp;if i == x:\n            <br />\n            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(i)\n          </code>\n          <br />\n          <p>\n            The input size is the <var>n</var> variable and not the <var>x</var>{\" \"}\n            variable. This is because, as the variable <var>n</var> varies, the\n            number of times the code run differs.<br></br>\n          </p>\n\n          <h6>Time complexity (rate-of-growth of running time)</h6>\n          <p>\n            How do we measure the rate-of-growth of the running time of an algorithm?\n            We can measure the running time of the algorithm, the literal\n            time consumed by the algorithm, but this depends on the computer\n            that is running it, thus it does not give a very best measure of an\n            algorithm.\n          </p>\n\n          <p>Instead, we can estimate the rate-of-growth of the running time by analysing the algorithm\n          using asymptotic analysis, the limiting behaviour of the algorithm as its input gets very large.\n          </p>\n\n          <h6>Analysis Types</h6>\n          <p>\n            There are three kinds of analyses:\n            <ul>\n              <li>\n                Worst-case analysis, analysis according to the maximum time that\n                can be consumed by the algorithm with input size n.\n              </li>\n              <li>\n                Average-case analysis, analysis according to the average time\n                that can be consumed by the algorithm with input size n.\n              </li>\n              <li>\n                Best-case analysis, analysis according to the average time\n                that can be consumed by the algorithm with input size n.\n              </li>\n            </ul>\n          </p>\n\n          <p>\n            We usually are interested in finding worst-case analysis and average-case analysiss. \n            Worst-case analysis is useful because we are usually interested to know an upper-limit guarantee.\n            Average-case analysis are useful in randomisation algorithms,\n            but best-case analysis is not really useful in most cases.\n          </p>\n\n          <h6>Asymptotic Notations</h6>\n          <p>\n            There are different asymptotic notations:\n             <ul>\n              <li>\n                &Omicron; (upper bound),\n                <pre> f(n) = &Omicron;(g(n))</pre> if there exists positive constant <pre>c</pre> and <pre>n<sub>0</sub></pre>,\n                such that <pre>0 &le; f(n) &le; c.g(n)</pre> for all <pre>n &ge; n<sub>0</sub></pre>.\n              </li>\n              <li>\n                &Theta; (tight bound),\n                <pre> f(n) = &Omega;(g(n))</pre> if there exists positive constant <pre>c1</pre>, <pre>c2</pre> and <pre>n<sub>0</sub></pre>,\n                such that <pre>0 &le; c<sub>1</sub>.g(n) &le; f(n) &le; c<sub>2</sub>.g(n)</pre> for all <pre>n &ge; n<sub>0</sub></pre>.\n              </li>\n              <li>\n                &Omega; (lower bound),\n                <pre> f(n) = &Theta;(g(n))</pre> if there exists positive constant <pre>c</pre> and <pre>n<sub>0</sub></pre>,\n                such that <pre>0 &le; c.g(n) &le; f(n)</pre> for all <pre>n &ge; n<sub>0</sub></pre>.\n              </li>\n            </ul>\n\n            Woah! What are these definitions?? Most of the time, people are overwhelmed when reading these definitions. What do they really mean? <br />\n            For example, you have a function <pre>f(n) = 2n<sup>2</sup></pre>. Let's try to find its upper, tight and lower bound.<br />\n            <ul>\n              <li>\n                <strong>Upper bound.</strong> Let's try <pre>g(n) = n<sup>3</sup></pre>. Is this upper bound of <pre>f(n) = 2n<sup>2</sup></pre>?<br />\n                In other words, does there exist positive constant <pre>c</pre> and <pre>n<sub>0</sub></pre>,  such that <pre>0 &le; c.g(n) &le; f(n)</pre> for all <pre>n &ge; n<sub>0</sub></pre>.<br />\n                Let's try <pre>c = 2</pre> and <pre>n<sub>0</sub> = 2</pre>. It is obvious that <pre>0 &le; 2n<sup>2</sup> &le; 2n<sup>3</sup></pre> for all <pre>n &ge; 2</pre>. <br />\n                As you can derive, other functions such as <pre>g(n) = n<sup>4</sup></pre>, <pre>g(n) = n<sup>5</sup></pre> can also be the upper bound of <pre>f(n)</pre>.<br />\n                But is this not a <strong>tight</strong> upper bound. Is there any tighter bound for <pre>f(n)</pre>?<br />\n                Let's try <pre>g(n) = n<sup>2</sup></pre>. Is this upper bound of <pre>f(n) = 2n<sup>2</sup></pre>?<br />\n                Let's try <pre>c = 3</pre> and <pre>n<sub>0</sub> = 2</pre>. It is obvious that <pre>0 &le; 2n<sup>2</sup> &le; 3n<sup>2</sup></pre> for all <pre>n &ge; 2</pre>. <br />\n                In fact, <pre>2n<sup>2</sup> = &Omicron;(n<sup>2</sup>)</pre>, <pre>n<sup>2</sup> is an upper bound of 2n<sup>2</sup></pre>! This is the tightest upper bound in-fact.\n              </li>\n              <li>\n                <strong>Lower bound.</strong> You can apply the same analysis for the lower bound and you will find that the tightest lower bound of <pre>f(n)</pre> is <pre>g(n) = n<sup>2</sup></pre>.\n                In other words, <pre>2n<sup>2</sup> = &Omega;(n<sup>2</sup>)</pre>.\n              </li>\n              <li>\n                <strong>Tight bound.</strong> We have arrived to the tightest upper and lower bound of <pre>f(n)</pre>, as you can guess, this is indeed the tight bound of the algorithm.<br />\n                This is one way to analyse at tight bound, find the tightest upper and lower bound, and they will converge to this tight bound.\n              </li>\n            </ul>\n          </p>\n\n          <h6>\n            Does upper-bound means worst-case analysis and tight bound means average case analysis? \n          </h6>\n          <p>\n            NO! This is a common misconception!<br />\n            For every type of analysis, especially worst-case and average-case we can calculate the different asymptotic behaviours, upper bound, tight bound and lower bound. \n          </p>\n\n          <p>\n            For example, in a worst-case analysis, <pre>f(n)</pre> = maximum number of steps run in an algorithm.\n            We can then apply the definitions above to look for the different asymptotic behaviours.\n          </p>\n\n\n        </Col>\n      </Row>\n    </Container>\n  );\n}\n","import React, { Component } from 'react';\n\nimport './Grid.css';\n\nexport default class Grid extends Component {\n  constructor(props) {\n    super(props);   \n  }\n\n  /**\n   * Determine additional properties of the grid that will affect its background color.\n   */\n  getAdditionalGridProps() {\n    var { isWallGrid, isStartGrid, isEndGrid } = this.props;\n    return isWallGrid ? 'grid-wall' : isStartGrid ? 'grid-start' : isEndGrid? 'grid-end': 'white'\n  }\n\n  render() {\n    return (\n      <td\n        id={`grid-${this.props.row}-${ this.props.col}`}\n        className={`grid ${this.getAdditionalGridProps()}`}\n        onMouseDown={() => this.props.onMouseDown(this.props.row, this.props.col)}\n        onMouseUp={() => this.props.onMouseUp(this.props.row, this.props.col)}\n        onMouseEnter={() => this.props.onMouseEnter(this.props.row, this.props.col)}\n        onMouseLeave={() => this.props.onMouseLeave(this.props.row, this.props.col)}\n      >\n      </td>\n    );\n  }\n}","function initializeGrids(allGrids) {\n  let initialGrids = [];\n  let startGrid = null;\n  let endGrid = null;\n  for (let row = 0; row < allGrids.length; row++) {\n    let currentRow = [];\n    for (let col = 0; col < allGrids[0].length; col++) {\n      const originalGrid = allGrids[row][col];\n      const modifiedGrid = initialGrid(originalGrid);\n      currentRow.push(modifiedGrid);\n      if (originalGrid.isStartGrid) startGrid = modifiedGrid;\n      if (originalGrid.isEndGrid) endGrid = modifiedGrid;\n    }\n    initialGrids.push(currentRow);\n  }\n  return [startGrid, endGrid, initialGrids];\n}\n\n\nfunction initialGrid(originalGrid) {\n  var {row, col, isVisited, isWallGrid, previousGrid} = originalGrid;\n  return {\n    row: row,\n    col: col,\n    isVisited: isVisited,\n    isWallGrid: isWallGrid,\n    previousGrid: previousGrid,\n    fValue: 0,\n    gValue: 0,\n    hValue: 0,\n  }\n}\n\nexport function astar(allGrids) {\n  return astarImplementation(...initializeGrids(allGrids));\n}\n\nfunction astarImplementation(startGrid, endGrid, allGrids) {\n  var visitedGridsInOrder = []\n  var openList = [];\n  var closedList = [];\n  openList.push(startGrid);\n\n  while (openList.length > 0) {\n    let lowestFOrH = 0;\n    for (let i = 0; i < openList.length; i++) {\n      if (openList[i].fValue < openList[lowestFOrH].fValue) {\n        lowestFOrH = i;\n      } else if (openList[i].fValue = openList[lowestFOrH].fValue) {\n        if (openList[i].hValue < openList[lowestFOrH].hValue) {\n          lowestFOrH = i;\n        }\n      }\n    }\n    let currentGrid = openList[lowestFOrH];\n\n    visitedGridsInOrder.push(currentGrid);\n    if (currentGrid.row === endGrid.row && currentGrid.col === endGrid.col) {\n      return [visitedGridsInOrder, getShortestPath(endGrid)]\n    }\n\n    const indexCurrentGrid = openList.indexOf(currentGrid);\n    if (indexCurrentGrid > -1) {\n      openList.splice(indexCurrentGrid, 1);\n    }\n    closedList.push(currentGrid);\n    let neighbors = getNeighborsOfGrid(currentGrid, allGrids, closedList);\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      \n      let currentG = currentGrid.gValue + 1;\n      let isBestG = false;\n\n      if (!isPartOfArray(neighbor, openList)) {\n        neighbor.hValue = Math.abs(neighbor.row - endGrid.row) + Math.abs(neighbor.col - endGrid.col);\n        isBestG = true;\n        openList.push(neighbor);\n      } else if (currentG < neighbor.gValue) {\n        isBestG = true;\n      }\n\n      if (isBestG) {\n        neighbor.gValue = currentG;\n        neighbor.fValue = neighbor.gValue + neighbor.hValue;\n        neighbor.previousGrid = currentGrid;\n      }\n    }\n  }\n  return [[], []];\n}\n\nfunction getShortestPath(endGrid) {\n  var shortestPath = [];\n  var currentGrid = endGrid;\n  while (currentGrid.previousGrid) {\n    shortestPath.unshift(currentGrid);\n    currentGrid = currentGrid.previousGrid;\n  }\n  return shortestPath;\n};\n\nfunction getNeighborsOfGrid(grid, allGrids, closedList) {\n  var neighborDown = grid.row < allGrids.length - 1 ? allGrids[grid.row + 1][grid.col] : null;\n  var neighborRight = grid.col < allGrids[0].length - 1 ? allGrids[grid.row][grid.col + 1] : null;\n  var neighborLeft = grid.col > 0 ? allGrids[grid.row][grid.col - 1] : null;\n  var neighborTop = grid.row > 0 ? allGrids[grid.row - 1][grid.col] : null;\n  return [neighborRight, neighborDown, neighborLeft, neighborTop].filter((neighbor) =>\n    neighbor !== null && (!neighbor.isWallGrid && !isPartOfArray(neighbor, closedList))\n  );\n}\n\nfunction isPartOfArray(grid, gridsList) {\n  return gridsList.some((item) => (item.row === grid.row && item.col === grid.col));\n}\n","function initializeGrids(allGrids) {\n  let initialGrids = [];\n  let startGrid = null;\n  let endGrid = null;\n  for (let row = 0; row < allGrids.length; row++) {\n    let currentRow = [];\n    for (let col = 0; col < allGrids[0].length; col++) {\n      const originalGrid = allGrids[row][col];\n      const modifiedGrid = initialGrid(originalGrid);\n      currentRow.push(modifiedGrid);\n      if (originalGrid.isStartGrid) startGrid = modifiedGrid;\n      if (originalGrid.isEndGrid) endGrid = modifiedGrid;\n    }\n    initialGrids.push(currentRow);\n  }\n  return [startGrid, endGrid, initialGrids];\n}\n\nfunction initialGrid(originalGrid) {\n  var { row, col, isVisited, isWallGrid, previousGrid } = originalGrid;\n  return {\n    row,\n    col,\n    isVisited: isVisited,\n    isWallGrid: isWallGrid,\n    previousGrid: previousGrid,\n    hValue: 0,\n  };\n}\n\nexport function greedyBestFirst(allGrids) {\n  return greedyBestFirstImplementation(...initializeGrids(allGrids));\n}\n\nexport function greedyBestFirstImplementation(startGrid, endGrid, allGrids) {\n  var visitedGridsInOrder = []\n  var openList = [];\n  var closedList = [];\n  openList.push(startGrid);\n\n  while (openList.length > 0) {\n    let lowestH = 0;\n    for (let i = 0; i < openList.length; i++) {\n      if (openList[i].hValue < openList[lowestH].hValue) {\n        lowestH = i;\n      }\n    }\n    let currentGrid = openList[lowestH];\n    visitedGridsInOrder.push(currentGrid);\n    if (currentGrid.row === endGrid.row && currentGrid.col === endGrid.col) {\n      return [closedList, getShortestPath(endGrid)]\n    }\n\n    const indexCurrentGrid = openList.indexOf(currentGrid);\n    if (indexCurrentGrid > -1) {\n      openList.splice(indexCurrentGrid, 1);\n    }\n    closedList.push(currentGrid);\n\n    let neighbors = getNeighborsOfGrid(currentGrid, allGrids, closedList);\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      neighbor.hValue = (Math.abs(neighbor.row - endGrid.row) + Math.abs(neighbor.col - endGrid.col))\n      openList.push(neighbor);\n      neighbor.previousGrid = currentGrid;\n    }\n  }\n  return [[], []];\n}\n\nfunction getShortestPath(endGrid) {\n  var shortestPath = [];\n  var currentGrid = endGrid;\n  while (currentGrid.previousGrid) {\n    console.log(currentGrid);\n    console.log(currentGrid.previousGrid)\n    shortestPath.unshift(currentGrid);\n    currentGrid = currentGrid.previousGrid;\n  }\n  return shortestPath;\n};\n\nfunction getNeighborsOfGrid(grid, allGrids, closedList) {\n  var neighborDown = grid.row < allGrids.length - 1 ? allGrids[grid.row + 1][grid.col] : null;\n  var neighborRight = grid.col < allGrids[0].length - 1 ? allGrids[grid.row][grid.col + 1] : null;\n  var neighborLeft = grid.col > 0 ? allGrids[grid.row][grid.col - 1] : null;\n  var neighborTop = grid.row > 0 ? allGrids[grid.row - 1][grid.col] : null;\n  return [neighborRight, neighborDown, neighborLeft, neighborTop].filter((neighbor) =>\n    neighbor !== null && (!neighbor.isWallGrid && !isPartOfArray(neighbor, closedList))\n  );\n}\n\nfunction isPartOfArray(grid, gridsList) {\n  return gridsList.some((item) => (item.row === grid.row && item.col === grid.col));\n}","function initializeGrids(allGrids) {\n  let initialGrids = [];\n  let startGrid = null;\n  let endGrid = null;\n  for (let row = 0; row < allGrids.length; row++) {\n    let currentRow = [];\n    for (let col = 0; col < allGrids[0].length; col++) {\n      const originalGrid = allGrids[row][col];\n      const modifiedGrid = initialGrid(originalGrid);\n      currentRow.push(modifiedGrid);\n      if (originalGrid.isStartGrid) startGrid = modifiedGrid;\n      if (originalGrid.isEndGrid) endGrid = modifiedGrid;\n    }\n    initialGrids.push(currentRow);\n  }\n  return [startGrid, endGrid, initialGrids];\n}\n\nfunction initialGrid(originalGrid) {\n  var { row, col, isVisited, isWallGrid, previousGrid } = originalGrid;\n  return {\n    row,\n    col,\n    distance: Infinity,\n    isVisited: isVisited,\n    isWallGrid: isWallGrid,\n    previousGrid: previousGrid,\n  };\n}\n\nexport function djikstra(allGrids) {\n  return djikstraImplementation(...initializeGrids(allGrids));\n}\n\n\nfunction djikstraImplementation(startGrid, endGrid, allGrids) {\n  var totalGrids = allGrids.length * allGrids[0].length;\n  var visitedGridsInOrder = [];\n  var allNodes = getAllGrids(allGrids);\n  startGrid.distance = 0;\n  while (visitedGridsInOrder.length !== totalGrids) {\n    sortGridsByDistance(allNodes);\n    var currentGrid = allNodes.shift();\n    if (currentGrid.isWallGrid) continue;\n    if (currentGrid.distance === Infinity) {\n      var shortestPath = [];\n      return [visitedGridsInOrder, shortestPath];\n    }\n    visitedGridsInOrder.push(currentGrid);\n    currentGrid.isVisited = true;\n    \n    relaxDistance(currentGrid, allGrids);\n    if (currentGrid === endGrid) {\n      shortestPath = getShortestPath(endGrid);\n      return [visitedGridsInOrder, shortestPath];\n    }\n  }\n  shortestPath = [];\n  return [visitedGridsInOrder, shortestPath];\n}\n\nfunction getAllGrids(allGrids) {\n  const grids = [];\n  for (const row of allGrids) {\n    for (const grid of row) {\n      if (!grid.isVisited) {\n        grids.push(grid);\n      }\n    }\n  }\n  return grids;\n}\n\nfunction getShortestPath(endGrid) {\n  var shortestPath = [];\n  var currentGrid = endGrid;\n  while (currentGrid) {\n    shortestPath.unshift(currentGrid);\n    currentGrid = currentGrid.previousGrid;\n  }\n  return shortestPath;\n}\n\nfunction sortGridsByDistance(allNodes) {\n  allNodes.sort((A, B) => A.distance - B.distance);\n}\n\nfunction relaxDistance(currentGrid, allGrids) {\n  var neighbors = getNeighborsOfGrid(currentGrid, allGrids);\n  updateNeighborsProperties(neighbors, currentGrid);\n  return neighbors;\n}\n\nfunction getNeighborsOfGrid(grid, allGrids) {\n  var neighborDown = grid.row < allGrids.length - 1 ? allGrids[grid.row + 1][grid.col]: null;\n  var neighborRight = grid.col < allGrids[0].length - 1 ? allGrids[grid.row][grid.col + 1]: null;\n  var neighborLeft = grid.col > 0 ? allGrids[grid.row][grid.col - 1] : null;\n  var neighborTop = grid.row > 0 ? allGrids[grid.row - 1][grid.col] : null;\n  return [neighborTop, neighborRight, neighborDown, neighborLeft].filter((neighbor) =>\n    neighbor !== null && (!neighbor.isVisited && !neighbor.isWallGrid)\n  );\n}\n\nfunction updateNeighborsProperties(neighbors, currentGrid) {\n  neighbors.map((neighbor) => {\n    if (neighbor !== null) {\n      neighbor.distance =\n        (neighbor.distance > currentGrid.distance + 1) ?\n          currentGrid.distance + 1\n          :\n          neighbor.distance;\n      neighbor.isVisited = true;\n      neighbor.previousGrid = currentGrid;\n    }\n  })\n}","function initializeGrids(allGrids) {\n  let initialGrids = [];\n  let startGrid = null;\n  let endGrid = null;\n  for (let row = 0; row < allGrids.length; row++) {\n    let currentRow = [];\n    for (let col = 0; col < allGrids[0].length; col++) {\n      const originalGrid = allGrids[row][col];\n      const modifiedGrid = initialGrid(originalGrid);\n      currentRow.push(modifiedGrid);\n      if (originalGrid.isStartGrid) startGrid = modifiedGrid;\n      if (originalGrid.isEndGrid) endGrid = modifiedGrid;\n    }\n    initialGrids.push(currentRow);\n  }\n  return [startGrid, endGrid, initialGrids];\n}\n\nfunction initialGrid(originalGrid) {\n  var { row, col, isVisited, isWallGrid, previousGrid } = originalGrid;\n  return {\n    row: row,\n    col: col,\n    isVisited: isVisited,\n    isWallGrid: isWallGrid,\n    previousGrid: previousGrid,\n  };\n}\n\nexport function bfs(allGrids) {\n  return bfsImplementation(...initializeGrids(allGrids));\n}\n\nfunction bfsImplementation(startGrid, endGrid, allGrids) {\n  var visitedGridsInOrder = [];\n  var queue = [startGrid];\n  startGrid.distance = 0;\n  while (queue.length !== 0) {\n    var currentGrid = queue.shift();\n    if (currentGrid.isWallGrid) continue;\n    visitedGridsInOrder.push(currentGrid);\n    currentGrid.isVisited = true;\n    updateNeighborsAndQueue(currentGrid, allGrids, queue);\n    if (currentGrid === endGrid) {\n      return [visitedGridsInOrder, getShortestPath(endGrid)];\n    }\n  }\n  return [visitedGridsInOrder, getShortestPath(endGrid)];\n}\n\nfunction getShortestPath(endGrid) {\n  var shortestPath = [];\n  var currentGrid = endGrid;\n  while (currentGrid) {\n    shortestPath.unshift(currentGrid);\n    currentGrid = currentGrid.previousGrid;\n  }\n  return shortestPath;\n}\n\nfunction updateNeighborsAndQueue(currentGrid, allGrids, queue) {\n  var neighbors = getNeighborsOfGrid(currentGrid, allGrids);\n  updateNeighborsProperties(neighbors, currentGrid, queue);\n  return neighbors;\n}\n\nfunction getNeighborsOfGrid(grid, allGrids) {\n  var neighborDown = grid.row < allGrids.length - 1 ? allGrids[grid.row + 1][grid.col] : null;\n  var neighborRight = grid.col < allGrids[0].length - 1 ? allGrids[grid.row][grid.col + 1] : null;\n  var neighborLeft = grid.col > 0 ? allGrids[grid.row][grid.col - 1] : null;\n  var neighborTop = grid.row > 0 ? allGrids[grid.row - 1][grid.col] : null;\n  return [neighborTop, neighborRight, neighborDown, neighborLeft].filter((neighbor) =>\n    neighbor !== null && (!neighbor.isVisited && !neighbor.isWallGrid)\n  );\n}\n\nfunction updateNeighborsProperties(neighbors, currentGrid, queue) {\n  neighbors.map((neighbor) => {\n    if (neighbor !== null) {\n      neighbor.isVisited = true;\n      neighbor.previousGrid = currentGrid;\n      queue.push(neighbor);\n    }\n  })\n}","import React from \"react\";\nimport { Badge, Container } from \"react-bootstrap\";\nimport \"./InfoBar.css\";\n\nexport function InfoBar() {\n  return (\n    <div class=\"info-bar\">\n      <Badge className=\"startGridBadge\">\n        Drag the yellow grid to set start position\n      </Badge>\n      <Badge className=\"endGridBadge\">\n        Drag the orange grid to set end position\n      </Badge>\n      <Badge className=\"wallGridBadge\">\n        Drag over the board to draw wall grids\n      </Badge>\n    </div>\n  );\n\n}\n","import React, { Component } from 'react';\nimport Grid from './Grid';\nimport { astar } from '../algorithms/AStar.js'\nimport { greedyBestFirst } from '../algorithms/GreedyBestFirst.js'\nimport { djikstra } from '../algorithms/Djikstra.js'\nimport { bfs } from '../algorithms/BFS.js'\nimport { Row, Button, Container } from 'react-bootstrap'\nimport { InfoBar } from \"./InfoBar\";\n\nimport './Grids.css';\n\nconst algoChoices = [\n  \"A* Search\",\n  \"BFS\",\n  \"Djikstra's Algorithm\",\n  \"Greedy Best First Search\",\n]\n\nexport class Grids extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      rowSize: 17,\n      colSize: 50,\n      startRow: 8,\n      startCol: 12,\n      endRow: 8,\n      endCol: 38,\n      grids: [],\n      mousePressed: false,\n      buttonDragged: null,\n      algo: \"A* Search\",\n      buttonsEnabled: true,\n      pureGrid: true,\n    };\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.visualizeAlgo = this.visualizeAlgo.bind(this);\n  }\n\n  componentDidMount() {\n    this.setState({ grids: this.setInitialGrids() });\n  }\n\n  /**\n   * Header element to choose algorithm and render 'visualize' button\n   */\n  header = () => {\n    return (\n      <Container className=\"grids-header\">\n          <label htmlFor=\"module-credit\">Algorithm</label>\n          <select\n            className=\"form-control\"\n            value={this.state.algo}\n            onChange={(e) => this.setState({ algo: e.target.value })}\n          >\n            {algoChoices.map((item) => (\n              <option key={item} value={item}>\n                {item}\n              </option>\n            ))}\n          </select>\n          <Button\n            onClick={this.visualizeAlgo}\n            disabled={!this.state.buttonsEnabled}\n          >\n            Visualize!\n          </Button>\n      </Container>\n    );\n  }\n\n  /**\n   * Return object of the grid at this row and column number\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  initialGrid(row, col) {\n    return {\n      row: row,\n      col: col,\n      isVisited: false,\n      isWallGrid: false,\n      isStartGrid: this.isStartGrid(row, col),\n      isEndGrid: this.isEndGrid(row, col),\n      previousGrid: null,\n    };\n  }\n\n  /**\n   * Set up initial grids state\n   */\n  setInitialGrids() {\n    let initialGrids = [];\n    for (let row = 0; row < this.state.rowSize; row++) {\n      let currentRow = [];\n      for (let col = 0; col < this.state.colSize; col++) {\n        currentRow.push(this.initialGrid(row, col));\n      }\n      initialGrids.push(currentRow);\n    }\n    return initialGrids;\n  }\n\n  /**\n   * Determine whether the grid at this row and col is a start grid\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  isStartGrid(row, col) {\n    return (row === this.state.startRow) && (col === this.state.startCol);\n  }\n\n  /**\n   * Determine whether the grid at this row and col is an end grid\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  isEndGrid(row, col) {\n    return (row === this.state.endRow) && (col === this.state.endCol)\n  }\n\n  /**\n   * Toggle a grid between a wall and non-wall grid\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  toggleWallGrid(row, col) {\n    this.setState(prevState => {\n      const newGrids = prevState.grids.slice();\n      const oldGrid = newGrids[row][col];\n      const newGrid = Object.assign({}, oldGrid, { isWallGrid: !oldGrid.isWallGrid });\n      newGrids[row][col] = newGrid;\n      return ({ grids: newGrids, mousePressed: true });\n    })\n  }\n\n  /**\n   * Change position of start or end grid to the specified row and column\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  toggleStartEndPosition(row, col) {\n    if (!this.state.pureGrid) {\n      this.resetColor();\n    }\n    this.setState(prevState => {\n      const newGrids = prevState.grids.slice();\n      const oldGrid = newGrids[row][col];\n      if (this.state.buttonDragged === 'start') {\n        const newGrid = Object.assign({}, oldGrid, { isStartGrid: !oldGrid.isStartGrid, isWallGrid: false });\n        newGrids[row][col] = newGrid;\n        return ({ grids: newGrids, startRow: row, startCol: col });\n      } else {\n        const newGrid = Object.assign({}, oldGrid, { isEndGrid: !oldGrid.isEndGrid, isWallGrid: false });\n        newGrids[row][col] = newGrid;\n        return ({ grids: newGrids, endRow: row, endCol: col });\n      }\n    });\n  }\n\n  /**\n   * Handle MouseDown event at that row and column\n   * If it is a start or end grid, set mousePressed property to true, so it can be dragged later\n   * If it is a normal or wall grid, toggle wall grids\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  handleMouseDown(row, col) {\n    if (this.state.buttonsEnabled) {\n      if (this.isStartGrid(row, col)) {\n        this.setState({ buttonDragged: \"start\", mousePressed: true });\n      } else if (this.isEndGrid(row, col)) {\n        this.setState({ buttonDragged: \"end\", mousePressed: true });\n      } else {\n        this.toggleWallGrid(row, col);\n      }\n    }\n  }\n\n  /**\n   * Handle MouseEnter event at that row and column\n   * If currently the button is dragging a start or end grid,\n   * set the start or end grid position to the current position\n   * If it is pressing position on normal or wall grids, toggle wall grid property. \n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  handleMouseEnter(row, col) {\n    if (this.state.buttonsEnabled) {\n      if (this.state.buttonDragged) {\n        this.toggleStartEndPosition(row, col);\n      } else if (this.state.mousePressed) {\n        if (this.isStartGrid(row, col) || this.isEndGrid(row, col)) {\n          return;\n        }\n        this.toggleWallGrid(row, col);\n      }\n    }\n  }\n\n  /**\n   * Handle MouseLeave event at this row and column\n   * If it just leaves a start or end grid, set the previous one to normal grid\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  handleMouseLeave(row, col) {\n    if (this.state.buttonsEnabled) {\n      if (this.state.buttonDragged) {\n        this.toggleStartEndPosition(row, col);\n      }\n    }\n  }\n\n  /**\n   * Handle MouseUp event\n   */\n  handleMouseUp() {\n    if (this.state.buttonsEnabled) {\n      this.setState({ mousePressed: false, buttonDragged: null });\n    }\n  }\n\n  /**\n   * Toggle buttonsEnabled state\n   */\n  toggleButtonsEnabled() {\n    if (this.state.buttonsEnabled) {\n      this.setState({ buttonsEnabled: false });\n    } else {\n      this.setState({ buttonsEnabled: true });\n    }\n  }\n\n  /**\n   * Reset color of all grids to background color\n   */\n  resetColor() {\n    for (let row = 0; row < this.state.rowSize; row++) {\n      for (let col = 0; col < this.state.colSize; col++) {\n        if ((row === this.state.startRow && col === this.state.startCol) || (row === this.state.endRow && col === this.state.endCol)) continue;\n        const item = this.state.grids[row][col];\n        if (item.isWallGrid) continue;\n        document.getElementById(`grid-${item.row}-${item.col}`).className = \"grid\";\n      }\n    }\n  }\n\n  /**\n   * Algo visualization trigger\n   */\n  visualizeAlgo() {\n    if (!this.state.pureGrid) {\n      this.resetColor();\n    }\n    this.setState({pureGrid: false})\n    this.toggleButtonsEnabled();\n\n    let [visitedGridsInOrder, shortestPathGrids] = [null, null];\n    switch (this.state.algo) {\n      case \"Djikstra's Algorithm\":\n        [visitedGridsInOrder, shortestPathGrids] = djikstra(this.state.grids);\n        break;\n      case \"BFS\":\n        [visitedGridsInOrder, shortestPathGrids] = bfs(this.state.grids);\n        break;\n      case \"A* Search\":\n        [visitedGridsInOrder, shortestPathGrids] = astar(this.state.grids);\n        break;\n      case \"Greedy Best First Search\":\n        [visitedGridsInOrder, shortestPathGrids] = greedyBestFirst(\n          this.state.grids\n        );\n        break;\n    }\n\n    visitedGridsInOrder.map((item, index) => {\n      if (index === visitedGridsInOrder.length -1 ) {\n        setTimeout(() => { this.visualizePath(shortestPathGrids);\n        }, 20 * visitedGridsInOrder.length);\n      }\n      setTimeout(() => {\n        document.getElementById(`grid-${item.row}-${item.col}`).className =\n          \"grid grid-visited\";\n        this.setStartEndGridClassName(item);\n      }, 20 * index);\n    });\n\n    setTimeout(() => {\n      this.toggleButtonsEnabled();\n    }, 20 * visitedGridsInOrder.length + 20 * shortestPathGrids.length + 50);\n  }\n\n  /**\n   * Set class name to grid-start or grid-end if it is a start or end grid\n   * @param {*} item The grid item\n   */\n  setStartEndGridClassName(item) {\n    if (this.isStartGrid(item.row, item.col)) {\n      document.getElementById(`grid-${item.row}-${item.col}`).className =\n        \"grid grid-start\";\n    } else if (this.isEndGrid(item.row, item.col)) {\n      document.getElementById(`grid-${item.row}-${item.col}`).className =\n        \"grid grid-end\";\n    }\n  }\n  \n  /**\n   * Function to visualize the path\n   * @param {*} shortestPathGrids The grid array that consttitutest the path\n   */\n  visualizePath(shortestPathGrids) {\n    shortestPathGrids.map((item, index) => {\n      setTimeout(() => {\n        document.getElementById(`grid-${item.row}-${item.col}`).className =\n          \"grid grid-shortest-path\";\n        this.setStartEndGridClassName(item);\n      }, 20 * index);\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        {this.header()}\n        <InfoBar />\n      <table>\n        {\n          this.state.grids.map((gridsRow, rowIndex) => {\n              return (\n                <tr key={rowIndex}>\n                  {gridsRow.map((gridsCol, colIndex) => {\n                    var { row, col, distance, isVisited, isWallGrid, isStartGrid, isEndGrid, previousGrid} = gridsCol;\n                      return (\n                        <Grid\n                          key={col}\n                          row={row}\n                          col={col}\n                          distance={distance}\n                          isVisited={isVisited}\n                          isWallGrid={isWallGrid}\n                          isStartGrid={isStartGrid}\n                          isEndGrid={isEndGrid}\n                          previousGrid={previousGrid}\n                          onMouseDown={this.handleMouseDown}\n                          onMouseUp={this.handleMouseUp}\n                          onMouseEnter={this.handleMouseEnter}\n                          onMouseLeave={this.handleMouseLeave}\n                        />\n                      );\n                    }\n                  )\n                  }\n                </tr>\n              )\n            }\n          )\n        }\n        </table>\n      </div>\n    )\n  }\n}","import React from \"react\";\nimport { Row, Col, Container } from \"react-bootstrap\";\nimport \"./Traversal.css\";\n\nexport function Traversal() {\n  return (\n    <Container>\n      <Row>\n        <Col>\n          <h6>\n            What does the time complexity visualizer actually measure and how does it measures?\n          </h6>\n          <p>\n            In the background, the visualizer actually inputs different values of <pre>n</pre> into the function that is submitted.\n            The visualizer then calculates the lines excecuted by the algorithm from these different <pre>n</pre> sizes.<br />\n            It then does a regression accross these values collected. In other words, it is trying to find the best function that represents <pre>f(n)</pre>.\n            This serves to be an estimation of the tight bound of the algorithm, though it might not be 100% accurate.\n          </p>\n\n          <p>\n            This is why, the visualizer only accepts one input, this input will be the size of n. For functions that have more than one input, no worries!\n             Look at the sample code provided in the visualizer for example to do this!\n          </p>\n\n          <h6>\n            Are we analysing the best, average of worst case of the algorithm?\n          </h6>\n          <p>\n            This acutally depends on the input that is given by the user. As mentioned in the theory explanation, \n            most of the time, we are interested in the worst-case analysis. How do we achieve this?<br />\n\n            Make sure that the input choice does not cause the algorithm to terminate early. For example, the sample function<br />\n            <code>\n              def f(x):\n              <br />\n              &nbsp;&nbsp;def binarySearch(arr, l, r, x): \n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;if r >= l: \n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid = l + (r - l) // 2\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if arr[mid] == x: \n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return mid \n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif arr[mid] > x: \n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return binarySearch(arr, mid + 1, r, x) \n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;else:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1\n              <br />\n              &nbsp;&nbsp;import random\n              <br />\n              &nbsp;&nbsp;for i in range(x):\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;arr = random.sample(range(0, x), x)\n              <br />\n              &nbsp;&nbsp;binarySearch(arr, 0, len(arr)-1, x+1)\n            </code>\n          </p>\n          <p>\n            The code is doing a binary search, it will terminate when it finds the number.<br />\n            How do we make sure that we are analysing the worst-case? Find number that is not in the array.<br />\n            In this case, the list contains number from 0 to <pre>x</pre> and the number searched is <pre>x + 1</pre>. <br />\n            Thus, this is a worst-case analysis.\n          </p>\n        </Col>\n      </Row>\n    </Container>\n  );\n}\n","import React from 'react';\nimport './App.css';\nimport { Theory } from \"./components/Theory\";\nimport { Grids } from \"./components/Grids\";\nimport { Traversal } from './components/Traversal';\nimport { BrowserRouter as Router, Switch, Route, NavLink } from \"react-router-dom\";\nimport { Nav } from \"react-bootstrap\";\n\nexport default function App() {\n    return (\n        <Router>\n            <div>\n                <nav className=\"navbar navbar-expand-sm navbar-light bg-custom header-bar\">\n                    <button\n                        className=\"navbar-toggler\"\n                        type=\"button\"\n                        data-toggle=\"collapse\"\n                        data-target=\"#navbarNav\"\n                        aria-controls=\"navbarNav\"\n                        aria-expanded=\"false\"\n                        aria-label=\"Toggle navigation\"\n                    >\n                        <span className=\"navbar-toggler-icon\"></span>\n                    </button>\n                    <div className=\"collapse navbar-collapse\" id=\"navbarNav\">\n                        <ul className=\"navbar-nav\">\n                            <li className=\"nav-item active\">\n                                <a className=\"nav-link\">\n                                    <Nav.Link\n                                        as={NavLink}\n                                        exact\n                                        to=\"/path-visualization\"\n                                        activeStyle={{\n                                            fontWeight: \"bold\",\n                                            color: \"black\",\n                                        }}\n                                    >\n                                        PATH VISUALIZER\n                                    </Nav.Link>\n                                </a>\n                            </li>\n                            <li className=\"nav-item\">\n                                <a className=\"nav-link\">\n                                    <Nav.Link\n                                        as={NavLink}\n                                        exact\n                                        to=\"/path-visualization/theory\"\n                                        activeStyle={{\n                                            fontWeight: \"bold\",\n                                            color: \"black\",\n                                        }}\n                                    >\n                                        GRAPH TRAVERSAL THEORY\n                                    </Nav.Link>\n                                </a>\n                            </li>\n                            <li className=\"nav-item\">\n                                <a className=\"nav-link\">\n                                    <Nav.Link\n                                        as={NavLink}\n                                        exact\n                                        to=\"/path-visualization/traversal\"\n                                        activeStyle={{\n                                            fontWeight: \"bold\",\n                                            color: \"black\",\n                                        }}\n                                    >\n                                        HOW THE VISUALIZER WORKS\n                                    </Nav.Link>\n                                </a>\n                            </li>\n                        </ul>\n                    </div>\n                </nav>\n\n                {/* A <Switch> looks through its children <Route>s and\n            renders the first one that matches the current URL. */}\n                <Switch>\n                    <Route path=\"/path-visualization/theory\">\n                        <Theory />\n                    </Route>\n                    <Route path=\"/path-visualization/traversal\">\n                        <Traversal />\n                    </Route>\n                    <Route path=\"/path-visualization\">\n                        <Grids />\n                    </Route>\n                </Switch>\n            </div>\n        </Router>\n    );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}