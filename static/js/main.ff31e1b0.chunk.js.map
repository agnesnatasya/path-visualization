{"version":3,"sources":["logo.svg","components/Title.js","components/InfoBar.js","components/Grids/Grid.js","algorithms/AStar.js","algorithms/GreedyBestFirst.js","algorithms/Djikstra.js","algorithms/BFS.js","components/Grids/Grids.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Title","className","InfoBar","Container","Badge","Grid","props","this","isWallGrid","isStartGrid","isEndGrid","id","row","col","getAdditionalGridProps","onMouseDown","onMouseUp","onMouseEnter","onMouseLeave","Component","initialGrid","originalGrid","isVisited","previousGrid","fValue","gValue","hValue","astar","allGrids","astarImplementation","initialGrids","startGrid","endGrid","length","currentRow","modifiedGrid","push","initializeGrids","visitedGridsInOrder","openList","closedList","lowestFOrH","i","currentGrid","getShortestPath","indexCurrentGrid","indexOf","splice","neighbors","getNeighborsOfGrid","neighbor","currentG","isBestG","isPartOfArray","Math","abs","shortestPath","unshift","grid","neighborDown","filter","gridsList","some","item","greedyBestFirst","greedyBestFirstImplementation","lowestH","console","log","distance","Infinity","djikstra","djikstraImplementation","totalGrids","allNodes","grids","getAllGrids","sortGridsByDistance","shift","relaxDistance","sort","A","B","neighborRight","neighborLeft","map","updateNeighborsProperties","bfs","bfsImplementation","queue","updateNeighborsAndQueue","algoChoices","Grids","header","htmlFor","value","state","algo","onChange","e","setState","target","key","Row","Button","onClick","visualizeAlgo","disabled","buttonsEnabled","rowSize","colSize","startRow","startCol","endRow","endCol","mousePressed","buttonDragged","pureGrid","handleMouseDown","bind","handleMouseEnter","handleMouseUp","handleMouseLeave","setInitialGrids","prevState","newGrids","slice","oldGrid","newGrid","Object","assign","resetColor","toggleWallGrid","toggleStartEndPosition","document","getElementById","toggleButtonsEnabled","shortestPathGrids","index","setTimeout","visualizePath","setStartEndGridClassName","gridsRow","rowIndex","gridsCol","colIndex","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.ff31e1b0.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React from \"react\";\nimport \"./Title.css\";\n\nexport function Title() {\n  return (\n    <div className=\"header-bar\">\n      <span className=\"title\">Path Visualizer</span>\n    </div>\n  );\n}\n","import React from \"react\";\nimport { Badge, Container } from \"react-bootstrap\";\nimport \"./InfoBar.css\";\n\nexport function InfoBar() {\n  return (\n    <Container>\n      <Badge className=\"startGridBadge\">\n        Drag the yellow grid to set start position\n      </Badge>\n      <Badge className=\"endGridBadge\">\n        Drag the orange grid to set end position\n      </Badge>\n      <Badge className=\"wallGridBadge\">\n        Drag over the board to draw wall grids\n      </Badge>\n    </Container>\n  );\n\n}\n","import React, { Component } from 'react';\n\nimport './Grid.css';\n\nexport default class Grid extends Component {\n  constructor(props) {\n    super(props);   \n  }\n\n  /**\n   * Determine additional properties of the grid that will affect its background color.\n   */\n  getAdditionalGridProps() {\n    var { isWallGrid, isStartGrid, isEndGrid } = this.props;\n    return isWallGrid ? 'grid-wall' : isStartGrid ? 'grid-start' : isEndGrid? 'grid-end': 'white'\n  }\n\n  render() {\n    return (\n      <td\n        id={`grid-${this.props.row}-${ this.props.col}`}\n        className={`grid ${this.getAdditionalGridProps()}`}\n        onMouseDown={() => this.props.onMouseDown(this.props.row, this.props.col)}\n        onMouseUp={() => this.props.onMouseUp(this.props.row, this.props.col)}\n        onMouseEnter={() => this.props.onMouseEnter(this.props.row, this.props.col)}\n        onMouseLeave={() => this.props.onMouseLeave(this.props.row, this.props.col)}\n      >\n      </td>\n    );\n  }\n}","function initializeGrids(allGrids) {\n  let initialGrids = [];\n  let startGrid = null;\n  let endGrid = null;\n  for (let row = 0; row < allGrids.length; row++) {\n    let currentRow = [];\n    for (let col = 0; col < allGrids[0].length; col++) {\n      const originalGrid = allGrids[row][col];\n      const modifiedGrid = initialGrid(originalGrid);\n      currentRow.push(modifiedGrid);\n      if (originalGrid.isStartGrid) startGrid = modifiedGrid;\n      if (originalGrid.isEndGrid) endGrid = modifiedGrid;\n    }\n    initialGrids.push(currentRow);\n  }\n  return [startGrid, endGrid, initialGrids];\n}\n\n\nfunction initialGrid(originalGrid) {\n  var {row, col, isVisited, isWallGrid, previousGrid} = originalGrid;\n  return {\n    row: row,\n    col: col,\n    isVisited: isVisited,\n    isWallGrid: isWallGrid,\n    previousGrid: previousGrid,\n    fValue: 0,\n    gValue: 0,\n    hValue: 0,\n  }\n}\n\nexport function astar(allGrids) {\n  return astarImplementation(...initializeGrids(allGrids));\n}\n\nfunction astarImplementation(startGrid, endGrid, allGrids) {\n  var visitedGridsInOrder = []\n  var openList = [];\n  var closedList = [];\n  openList.push(startGrid);\n\n  while (openList.length > 0) {\n    let lowestFOrH = 0;\n    for (let i = 0; i < openList.length; i++) {\n      if (openList[i].fValue < openList[lowestFOrH].fValue) {\n        lowestFOrH = i;\n      } else if (openList[i].fValue = openList[lowestFOrH].fValue) {\n        if (openList[i].hValue < openList[lowestFOrH].hValue) {\n          lowestFOrH = i;\n        }\n      }\n    }\n    let currentGrid = openList[lowestFOrH];\n\n    visitedGridsInOrder.push(currentGrid);\n    if (currentGrid.row === endGrid.row && currentGrid.col === endGrid.col) {\n      return [visitedGridsInOrder, getShortestPath(endGrid)]\n    }\n\n    const indexCurrentGrid = openList.indexOf(currentGrid);\n    if (indexCurrentGrid > -1) {\n      openList.splice(indexCurrentGrid, 1);\n    }\n    closedList.push(currentGrid);\n    let neighbors = getNeighborsOfGrid(currentGrid, allGrids, closedList);\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      \n      let currentG = currentGrid.gValue + 1;\n      let isBestG = false;\n\n      if (!isPartOfArray(neighbor, openList)) {\n        neighbor.hValue = Math.abs(neighbor.row - endGrid.row) + Math.abs(neighbor.col - endGrid.col);\n        isBestG = true;\n        openList.push(neighbor);\n      } else if (currentG < neighbor.gValue) {\n        isBestG = true;\n      }\n\n      if (isBestG) {\n        neighbor.gValue = currentG;\n        neighbor.fValue = neighbor.gValue + neighbor.hValue;\n        neighbor.previousGrid = currentGrid;\n      }\n    }\n  }\n  return [[], []];\n}\n\nfunction getShortestPath(endGrid) {\n  var shortestPath = [];\n  var currentGrid = endGrid;\n  while (currentGrid.previousGrid) {\n    shortestPath.unshift(currentGrid);\n    currentGrid = currentGrid.previousGrid;\n  }\n  return shortestPath;\n};\n\nfunction getNeighborsOfGrid(grid, allGrids, closedList) {\n  var neighborDown = grid.row < allGrids.length - 1 ? allGrids[grid.row + 1][grid.col] : null;\n  var neighborRight = grid.col < allGrids[0].length - 1 ? allGrids[grid.row][grid.col + 1] : null;\n  var neighborLeft = grid.col > 0 ? allGrids[grid.row][grid.col - 1] : null;\n  var neighborTop = grid.row > 0 ? allGrids[grid.row - 1][grid.col] : null;\n  return [neighborRight, neighborDown, neighborLeft, neighborTop].filter((neighbor) =>\n    neighbor !== null && (!neighbor.isWallGrid && !isPartOfArray(neighbor, closedList))\n  );\n}\n\nfunction isPartOfArray(grid, gridsList) {\n  return gridsList.some((item) => (item.row === grid.row && item.col === grid.col));\n}\n","function initializeGrids(allGrids) {\n  let initialGrids = [];\n  let startGrid = null;\n  let endGrid = null;\n  for (let row = 0; row < allGrids.length; row++) {\n    let currentRow = [];\n    for (let col = 0; col < allGrids[0].length; col++) {\n      const originalGrid = allGrids[row][col];\n      const modifiedGrid = initialGrid(originalGrid);\n      currentRow.push(modifiedGrid);\n      if (originalGrid.isStartGrid) startGrid = modifiedGrid;\n      if (originalGrid.isEndGrid) endGrid = modifiedGrid;\n    }\n    initialGrids.push(currentRow);\n  }\n  return [startGrid, endGrid, initialGrids];\n}\n\nfunction initialGrid(originalGrid) {\n  var { row, col, isVisited, isWallGrid, previousGrid } = originalGrid;\n  return {\n    row,\n    col,\n    isVisited: isVisited,\n    isWallGrid: isWallGrid,\n    previousGrid: previousGrid,\n    hValue: 0,\n  };\n}\n\nexport function greedyBestFirst(allGrids) {\n  return greedyBestFirstImplementation(...initializeGrids(allGrids));\n}\n\nexport function greedyBestFirstImplementation(startGrid, endGrid, allGrids) {\n  var visitedGridsInOrder = []\n  var openList = [];\n  var closedList = [];\n  openList.push(startGrid);\n\n  while (openList.length > 0) {\n    let lowestH = 0;\n    for (let i = 0; i < openList.length; i++) {\n      if (openList[i].hValue < openList[lowestH].hValue) {\n        lowestH = i;\n      }\n    }\n    let currentGrid = openList[lowestH];\n    visitedGridsInOrder.push(currentGrid);\n    if (currentGrid.row === endGrid.row && currentGrid.col === endGrid.col) {\n      return [closedList, getShortestPath(endGrid)]\n    }\n\n    const indexCurrentGrid = openList.indexOf(currentGrid);\n    if (indexCurrentGrid > -1) {\n      openList.splice(indexCurrentGrid, 1);\n    }\n    closedList.push(currentGrid);\n\n    let neighbors = getNeighborsOfGrid(currentGrid, allGrids, closedList);\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      neighbor.hValue = (Math.abs(neighbor.row - endGrid.row) + Math.abs(neighbor.col - endGrid.col))\n      openList.push(neighbor);\n      neighbor.previousGrid = currentGrid;\n    }\n  }\n  return [[], []];\n}\n\nfunction getShortestPath(endGrid) {\n  var shortestPath = [];\n  var currentGrid = endGrid;\n  while (currentGrid.previousGrid) {\n    console.log(currentGrid);\n    console.log(currentGrid.previousGrid)\n    shortestPath.unshift(currentGrid);\n    currentGrid = currentGrid.previousGrid;\n  }\n  return shortestPath;\n};\n\nfunction getNeighborsOfGrid(grid, allGrids, closedList) {\n  var neighborDown = grid.row < allGrids.length - 1 ? allGrids[grid.row + 1][grid.col] : null;\n  var neighborRight = grid.col < allGrids[0].length - 1 ? allGrids[grid.row][grid.col + 1] : null;\n  var neighborLeft = grid.col > 0 ? allGrids[grid.row][grid.col - 1] : null;\n  var neighborTop = grid.row > 0 ? allGrids[grid.row - 1][grid.col] : null;\n  return [neighborRight, neighborDown, neighborLeft, neighborTop].filter((neighbor) =>\n    neighbor !== null && (!neighbor.isWallGrid && !isPartOfArray(neighbor, closedList))\n  );\n}\n\nfunction isPartOfArray(grid, gridsList) {\n  return gridsList.some((item) => (item.row === grid.row && item.col === grid.col));\n}","function initializeGrids(allGrids) {\n  let initialGrids = [];\n  let startGrid = null;\n  let endGrid = null;\n  for (let row = 0; row < allGrids.length; row++) {\n    let currentRow = [];\n    for (let col = 0; col < allGrids[0].length; col++) {\n      const originalGrid = allGrids[row][col];\n      const modifiedGrid = initialGrid(originalGrid);\n      currentRow.push(modifiedGrid);\n      if (originalGrid.isStartGrid) startGrid = modifiedGrid;\n      if (originalGrid.isEndGrid) endGrid = modifiedGrid;\n    }\n    initialGrids.push(currentRow);\n  }\n  return [startGrid, endGrid, initialGrids];\n}\n\nfunction initialGrid(originalGrid) {\n  var { row, col, isVisited, isWallGrid, previousGrid } = originalGrid;\n  return {\n    row,\n    col,\n    distance: Infinity,\n    isVisited: isVisited,\n    isWallGrid: isWallGrid,\n    previousGrid: previousGrid,\n  };\n}\n\nexport function djikstra(allGrids) {\n  return djikstraImplementation(...initializeGrids(allGrids));\n}\n\n\nfunction djikstraImplementation(startGrid, endGrid, allGrids) {\n  var totalGrids = allGrids.length * allGrids[0].length;\n  var visitedGridsInOrder = [];\n  var allNodes = getAllGrids(allGrids);\n  startGrid.distance = 0;\n  while (visitedGridsInOrder.length !== totalGrids) {\n    sortGridsByDistance(allNodes);\n    var currentGrid = allNodes.shift();\n    if (currentGrid.isWallGrid) continue;\n    if (currentGrid.distance === Infinity) {\n      var shortestPath = [];\n      return [visitedGridsInOrder, shortestPath];\n    }\n    visitedGridsInOrder.push(currentGrid);\n    currentGrid.isVisited = true;\n    \n    relaxDistance(currentGrid, allGrids);\n    if (currentGrid === endGrid) {\n      shortestPath = getShortestPath(endGrid);\n      return [visitedGridsInOrder, shortestPath];\n    }\n  }\n  shortestPath = [];\n  return [visitedGridsInOrder, shortestPath];\n}\n\nfunction getAllGrids(allGrids) {\n  const grids = [];\n  for (const row of allGrids) {\n    for (const grid of row) {\n      if (!grid.isVisited) {\n        grids.push(grid);\n      }\n    }\n  }\n  return grids;\n}\n\nfunction getShortestPath(endGrid) {\n  var shortestPath = [];\n  var currentGrid = endGrid;\n  while (currentGrid) {\n    shortestPath.unshift(currentGrid);\n    currentGrid = currentGrid.previousGrid;\n  }\n  return shortestPath;\n}\n\nfunction sortGridsByDistance(allNodes) {\n  allNodes.sort((A, B) => A.distance - B.distance);\n}\n\nfunction relaxDistance(currentGrid, allGrids) {\n  var neighbors = getNeighborsOfGrid(currentGrid, allGrids);\n  updateNeighborsProperties(neighbors, currentGrid);\n  return neighbors;\n}\n\nfunction getNeighborsOfGrid(grid, allGrids) {\n  var neighborDown = grid.row < allGrids.length - 1 ? allGrids[grid.row + 1][grid.col]: null;\n  var neighborRight = grid.col < allGrids[0].length - 1 ? allGrids[grid.row][grid.col + 1]: null;\n  var neighborLeft = grid.col > 0 ? allGrids[grid.row][grid.col - 1] : null;\n  var neighborTop = grid.row > 0 ? allGrids[grid.row - 1][grid.col] : null;\n  return [neighborTop, neighborRight, neighborDown, neighborLeft].filter((neighbor) =>\n    neighbor !== null && (!neighbor.isVisited && !neighbor.isWallGrid)\n  );\n}\n\nfunction updateNeighborsProperties(neighbors, currentGrid) {\n  neighbors.map((neighbor) => {\n    if (neighbor !== null) {\n      neighbor.distance =\n        (neighbor.distance > currentGrid.distance + 1) ?\n          currentGrid.distance + 1\n          :\n          neighbor.distance;\n      neighbor.isVisited = true;\n      neighbor.previousGrid = currentGrid;\n    }\n  })\n}","function initializeGrids(allGrids) {\n  let initialGrids = [];\n  let startGrid = null;\n  let endGrid = null;\n  for (let row = 0; row < allGrids.length; row++) {\n    let currentRow = [];\n    for (let col = 0; col < allGrids[0].length; col++) {\n      const originalGrid = allGrids[row][col];\n      const modifiedGrid = initialGrid(originalGrid);\n      currentRow.push(modifiedGrid);\n      if (originalGrid.isStartGrid) startGrid = modifiedGrid;\n      if (originalGrid.isEndGrid) endGrid = modifiedGrid;\n    }\n    initialGrids.push(currentRow);\n  }\n  return [startGrid, endGrid, initialGrids];\n}\n\nfunction initialGrid(originalGrid) {\n  var { row, col, isVisited, isWallGrid, previousGrid } = originalGrid;\n  return {\n    row: row,\n    col: col,\n    isVisited: isVisited,\n    isWallGrid: isWallGrid,\n    previousGrid: previousGrid,\n  };\n}\n\nexport function bfs(allGrids) {\n  return bfsImplementation(...initializeGrids(allGrids));\n}\n\nfunction bfsImplementation(startGrid, endGrid, allGrids) {\n  var visitedGridsInOrder = [];\n  var queue = [startGrid];\n  startGrid.distance = 0;\n  while (queue.length !== 0) {\n    var currentGrid = queue.shift();\n    if (currentGrid.isWallGrid) continue;\n    visitedGridsInOrder.push(currentGrid);\n    currentGrid.isVisited = true;\n    updateNeighborsAndQueue(currentGrid, allGrids, queue);\n    if (currentGrid === endGrid) {\n      return [visitedGridsInOrder, getShortestPath(endGrid)];\n    }\n  }\n  return [visitedGridsInOrder, getShortestPath(endGrid)];\n}\n\nfunction getShortestPath(endGrid) {\n  var shortestPath = [];\n  var currentGrid = endGrid;\n  while (currentGrid) {\n    shortestPath.unshift(currentGrid);\n    currentGrid = currentGrid.previousGrid;\n  }\n  return shortestPath;\n}\n\nfunction updateNeighborsAndQueue(currentGrid, allGrids, queue) {\n  var neighbors = getNeighborsOfGrid(currentGrid, allGrids);\n  updateNeighborsProperties(neighbors, currentGrid, queue);\n  return neighbors;\n}\n\nfunction getNeighborsOfGrid(grid, allGrids) {\n  var neighborDown = grid.row < allGrids.length - 1 ? allGrids[grid.row + 1][grid.col] : null;\n  var neighborRight = grid.col < allGrids[0].length - 1 ? allGrids[grid.row][grid.col + 1] : null;\n  var neighborLeft = grid.col > 0 ? allGrids[grid.row][grid.col - 1] : null;\n  var neighborTop = grid.row > 0 ? allGrids[grid.row - 1][grid.col] : null;\n  return [neighborTop, neighborRight, neighborDown, neighborLeft].filter((neighbor) =>\n    neighbor !== null && (!neighbor.isVisited && !neighbor.isWallGrid)\n  );\n}\n\nfunction updateNeighborsProperties(neighbors, currentGrid, queue) {\n  neighbors.map((neighbor) => {\n    if (neighbor !== null) {\n      neighbor.isVisited = true;\n      neighbor.previousGrid = currentGrid;\n      queue.push(neighbor);\n    }\n  })\n}","import React, { Component } from 'react';\nimport Grid from './Grid';\nimport { astar } from '../../algorithms/AStar.js'\nimport { greedyBestFirst } from '../../algorithms/GreedyBestFirst.js'\nimport { djikstra } from '../../algorithms/Djikstra.js'\nimport { bfs } from '../../algorithms/BFS.js'\nimport { Row, Button, Container } from 'react-bootstrap'\n\nimport './Grids.css';\n\nconst algoChoices = [\n  \"A* Search\",\n  \"BFS\",\n  \"Djikstra's Algorithm\",\n  \"Greedy Best First Search\",\n]\n\nexport default class Grids extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      rowSize: 25,\n      colSize: 25,\n      startRow: 12,\n      startCol: 5,\n      endRow: 12,\n      endCol: 19,\n      grids: [],\n      mousePressed: false,\n      buttonDragged: null,\n      algo: \"A* Search\",\n      buttonsEnabled: true,\n      pureGrid: true,\n    };\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.visualizeAlgo = this.visualizeAlgo.bind(this);\n  }\n\n  componentDidMount() {\n    this.setState({ grids: this.setInitialGrids() });\n  }\n\n  /**\n   * Header element to choose algorithm and render 'visualize' button\n   */\n  header = () => {\n    return (\n      <Container>\n          <label htmlFor=\"module-credit\">Algorithm</label>\n          <select\n            className=\"form-control\"\n            value={this.state.algo}\n            onChange={(e) => this.setState({ algo: e.target.value })}\n          >\n            {algoChoices.map((item) => (\n              <option key={item} value={item}>\n                {item}\n              </option>\n            ))}\n          </select>\n        <Row>\n          <Button\n            onClick={this.visualizeAlgo}\n            disabled={!this.state.buttonsEnabled}\n          >\n            Visualize!\n          </Button>\n        </Row>\n      </Container>\n    );\n  }\n\n  /**\n   * Return object of the grid at this row and column number\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  initialGrid(row, col) {\n    return {\n      row: row,\n      col: col,\n      isVisited: false,\n      isWallGrid: false,\n      isStartGrid: this.isStartGrid(row, col),\n      isEndGrid: this.isEndGrid(row, col),\n      previousGrid: null,\n    };\n  }\n\n  /**\n   * Set up initial grids state\n   */\n  setInitialGrids() {\n    let initialGrids = [];\n    for (let row = 0; row < this.state.rowSize; row++) {\n      let currentRow = [];\n      for (let col = 0; col < this.state.colSize; col++) {\n        currentRow.push(this.initialGrid(row, col));\n      }\n      initialGrids.push(currentRow);\n    }\n    return initialGrids;\n  }\n\n  /**\n   * Determine whether the grid at this row and col is a start grid\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  isStartGrid(row, col) {\n    return (row === this.state.startRow) && (col === this.state.startCol);\n  }\n\n  /**\n   * Determine whether the grid at this row and col is an end grid\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  isEndGrid(row, col) {\n    return (row === this.state.endRow) && (col === this.state.endCol)\n  }\n\n  /**\n   * Toggle a grid between a wall and non-wall grid\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  toggleWallGrid(row, col) {\n    this.setState(prevState => {\n      const newGrids = prevState.grids.slice();\n      const oldGrid = newGrids[row][col];\n      const newGrid = Object.assign({}, oldGrid, { isWallGrid: !oldGrid.isWallGrid });\n      newGrids[row][col] = newGrid;\n      return ({ grids: newGrids, mousePressed: true });\n    })\n  }\n\n  /**\n   * Change position of start or end grid to the specified row and column\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  toggleStartEndPosition(row, col) {\n    if (!this.state.pureGrid) {\n      this.resetColor();\n    }\n    this.setState(prevState => {\n      const newGrids = prevState.grids.slice();\n      const oldGrid = newGrids[row][col];\n      if (this.state.buttonDragged === 'start') {\n        const newGrid = Object.assign({}, oldGrid, { isStartGrid: !oldGrid.isStartGrid, isWallGrid: false });\n        newGrids[row][col] = newGrid;\n        return ({ grids: newGrids, startRow: row, startCol: col });\n      } else {\n        const newGrid = Object.assign({}, oldGrid, { isEndGrid: !oldGrid.isEndGrid, isWallGrid: false });\n        newGrids[row][col] = newGrid;\n        return ({ grids: newGrids, endRow: row, endCol: col });\n      }\n    });\n  }\n\n  /**\n   * Handle MouseDown event at that row and column\n   * If it is a start or end grid, set mousePressed property to true, so it can be dragged later\n   * If it is a normal or wall grid, toggle wall grids\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  handleMouseDown(row, col) {\n    if (this.state.buttonsEnabled) {\n      if (this.isStartGrid(row, col)) {\n        this.setState({ buttonDragged: \"start\", mousePressed: true });\n      } else if (this.isEndGrid(row, col)) {\n        this.setState({ buttonDragged: \"end\", mousePressed: true });\n      } else {\n        this.toggleWallGrid(row, col);\n      }\n    }\n  }\n\n  /**\n   * Handle MouseEnter event at that row and column\n   * If currently the button is dragging a start or end grid,\n   * set the start or end grid position to the current position\n   * If it is pressing position on normal or wall grids, toggle wall grid property. \n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  handleMouseEnter(row, col) {\n    if (this.state.buttonsEnabled) {\n      if (this.state.buttonDragged) {\n        this.toggleStartEndPosition(row, col);\n      } else if (this.state.mousePressed) {\n        if (this.isStartGrid(row, col) || this.isEndGrid(row, col)) {\n          return;\n        }\n        this.toggleWallGrid(row, col);\n      }\n    }\n  }\n\n  /**\n   * Handle MouseLeave event at this row and column\n   * If it just leaves a start or end grid, set the previous one to normal grid\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  handleMouseLeave(row, col) {\n    if (this.state.buttonsEnabled) {\n      if (this.state.buttonDragged) {\n        this.toggleStartEndPosition(row, col);\n      }\n    }\n  }\n\n  /**\n   * Handle MouseUp event\n   */\n  handleMouseUp() {\n    if (this.state.buttonsEnabled) {\n      this.setState({ mousePressed: false, buttonDragged: null });\n    }\n  }\n\n  /**\n   * Toggle buttonsEnabled state\n   */\n  toggleButtonsEnabled() {\n    if (this.state.buttonsEnabled) {\n      this.setState({ buttonsEnabled: false });\n    } else {\n      this.setState({ buttonsEnabled: true });\n    }\n  }\n\n  /**\n   * Reset color of all grids to background color\n   */\n  resetColor() {\n    for (let row = 0; row < this.state.rowSize; row++) {\n      for (let col = 0; col < this.state.colSize; col++) {\n        if ((row === this.state.startRow && col === this.state.startCol) || (row === this.state.endRow && col === this.state.endCol)) continue;\n        const item = this.state.grids[row][col];\n        if (item.isWallGrid) continue;\n        document.getElementById(`grid-${item.row}-${item.col}`).className = \"grid\";\n      }\n    }\n  }\n\n  /**\n   * Algo visualization trigger\n   */\n  visualizeAlgo() {\n    if (!this.state.pureGrid) {\n      this.resetColor();\n    }\n    this.setState({pureGrid: false})\n    this.toggleButtonsEnabled();\n\n    let [visitedGridsInOrder, shortestPathGrids] = [null, null];\n    switch (this.state.algo) {\n      case \"Djikstra's Algorithm\":\n        [visitedGridsInOrder, shortestPathGrids] = djikstra(this.state.grids);\n        break;\n      case \"BFS\":\n        [visitedGridsInOrder, shortestPathGrids] = bfs(this.state.grids);\n        break;\n      case \"A* Search\":\n        [visitedGridsInOrder, shortestPathGrids] = astar(this.state.grids);\n        break;\n      case \"Greedy Best First Search\":\n        [visitedGridsInOrder, shortestPathGrids] = greedyBestFirst(\n          this.state.grids\n        );\n        break;\n    }\n\n    visitedGridsInOrder.map((item, index) => {\n      if (index === visitedGridsInOrder.length -1 ) {\n        setTimeout(() => { this.visualizePath(shortestPathGrids);\n        }, 20 * visitedGridsInOrder.length);\n      }\n      setTimeout(() => {\n        document.getElementById(`grid-${item.row}-${item.col}`).className =\n          \"grid grid-visited\";\n        this.setStartEndGridClassName(item);\n      }, 20 * index);\n    });\n\n    setTimeout(() => {\n      this.toggleButtonsEnabled();\n    }, 20 * visitedGridsInOrder.length + 20 * shortestPathGrids.length + 50);\n  }\n\n  /**\n   * Set class name to grid-start or grid-end if it is a start or end grid\n   * @param {*} item The grid item\n   */\n  setStartEndGridClassName(item) {\n    if (this.isStartGrid(item.row, item.col)) {\n      document.getElementById(`grid-${item.row}-${item.col}`).className =\n        \"grid grid-start\";\n    } else if (this.isEndGrid(item.row, item.col)) {\n      document.getElementById(`grid-${item.row}-${item.col}`).className =\n        \"grid grid-end\";\n    }\n  }\n  \n  /**\n   * Function to visualize the path\n   * @param {*} shortestPathGrids The grid array that consttitutest the path\n   */\n  visualizePath(shortestPathGrids) {\n    shortestPathGrids.map((item, index) => {\n      setTimeout(() => {\n        document.getElementById(`grid-${item.row}-${item.col}`).className =\n          \"grid grid-shortest-path\";\n        this.setStartEndGridClassName(item);\n      }, 20 * index);\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        {this.header()}\n      <table>\n        {\n          this.state.grids.map((gridsRow, rowIndex) => {\n              return (\n                <tr key={rowIndex}>\n                  {gridsRow.map((gridsCol, colIndex) => {\n                    var { row, col, distance, isVisited, isWallGrid, isStartGrid, isEndGrid, previousGrid} = gridsCol;\n                      return (\n                        <Grid\n                          key={col}\n                          row={row}\n                          col={col}\n                          distance={distance}\n                          isVisited={isVisited}\n                          isWallGrid={isWallGrid}\n                          isStartGrid={isStartGrid}\n                          isEndGrid={isEndGrid}\n                          previousGrid={previousGrid}\n                          onMouseDown={this.handleMouseDown}\n                          onMouseUp={this.handleMouseUp}\n                          onMouseEnter={this.handleMouseEnter}\n                          onMouseLeave={this.handleMouseLeave}\n                        />\n                      );\n                    }\n                  )\n                  }\n                </tr>\n              )\n            }\n          )\n        }\n        </table>\n      </div>\n    )\n  }\n}","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { Title } from './components/Title';\nimport { InfoBar } from \"./components/InfoBar\";\nimport Grids from \"./components/Grids/Grids.js\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Title />\n      <InfoBar />\n      <Grids />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}