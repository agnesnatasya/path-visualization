(this["webpackJsonppath-visualization"]=this["webpackJsonppath-visualization"]||[]).push([[0],{36:function(e,t,r){e.exports=r(57)},41:function(e,t,r){},42:function(e,t,r){},43:function(e,t,r){},44:function(e,t,r){},45:function(e,t,r){},46:function(e,t,r){},47:function(e,t,r){},57:function(e,t,r){"use strict";r.r(t);var a=r(0),n=r.n(a),l=r(29),i=r.n(l),o=(r(41),r(42),r(58)),s=r(59),u=r(60);r(43);function c(){return n.a.createElement(o.a,{className:"content"},n.a.createElement(s.a,null,n.a.createElement(u.a,null,n.a.createElement("h6",null,"What is graph traversal?"),n.a.createElement("strong",null,"Graph traversal")," is the process of visiting vertices in a graph, through the edges. In this visualizer, we depict a single source and single goal node, thus the goal is to reach the goal node from the start node. There are other graph traversal which involves multiple starting or goal node, but it is not discussed here. ",n.a.createElement("br",null),"There are two types of graph traversal:",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("b",null,"Uninformed search"),". In an uninformed search, the algorithm does not have any idea about how far the current node is to the goal node. Thus, it takes decision according to other known informations, such as the distance from the start node to a goal node."),n.a.createElement("li",null,n.a.createElement("b",null,"Informed search"),". In an informed search, the algorithm have information about how far the current node to the goal node is. Thus, it could make decision acccording to this information. Intuitively, you would want to explore nodes that are nearer to the goal node.")),n.a.createElement("h6",null,"Are the grids in the visualizer a graph? ",n.a.createElement("br",null)),"Yes, the grids represents a graph. Though graph is usually represented in a more disordered way, the grids in the visualizer is also a graph. Every grid in the graph is connected to either 2 or 3 or 4 adjacent grids. The graph is undirected.",n.a.createElement("br",null),n.a.createElement("h6",null,"Uninformed Search"),"Algorithm which falls under uninformed search includes Breadth-First Search (BFS), Depth-First Search (DFS), Uniform-Cost Search (UCS), Dijkstra's Algorithm.",n.a.createElement("br",null),n.a.createElement("br",null),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("strong",null,"Breadth-First Search.")," The idea of BFS is from a single node, traverse all of its neighbors. After done, traverse the neighbors of neighbors. Thus, it is breadth-first, it traverse all nodes which are at a current layer before moving on to the next layer of nodes."),"Here is a pseudocode of BFS algorithm",n.a.createElement("br",null),n.a.createElement("code",null,"def BFS(start):",n.a.createElement("br",null),"\xa0\xa0queue = Queue(start)",n.a.createElement("br",null),"\xa0\xa0visited = List(start)",n.a.createElement("br",null),"\xa0\xa0while queue is not empty:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0current = queue.pop()",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0for all neighbor of current:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0if neighbor === goal:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return neighbor",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0else:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if neighbor not in visited:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0visited.add(neighbor)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0queue.add(neighbor)")),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("strong",null,"Depth-First Search.")," The idea of DFS is from a single node, explore its first neighbor. Then explore the first neighbor of this first neighbor and so on until it reaches a dead-end. After that, explore the second neighbor, and so on. The implementation is very similar to BFS with a slight modification of the data structure."),"Here is a pseudocode of DFS algorithm",n.a.createElement("br",null),n.a.createElement("code",null,"def DFS(start):",n.a.createElement("br",null),"\xa0\xa0stack = Stack(start)",n.a.createElement("br",null),"\xa0\xa0visited = List(start)",n.a.createElement("br",null),"\xa0\xa0while stack is not empty:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0current = queue.pop()",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0for all neighbor of current:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0if neighbor === goal:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return neighbor",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0else:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if neighbor not in visited:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0visited.add(neighbor)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0queue.add(neighbor)")),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("strong",null,"Dijkstra's Algorithm.")," Both BFS and DFS above does not keep track of path cost. Thus, the path that it chooses to reach the goal node might not be the cheapest, or the optimal. Dijkstra's Algorithm is an algorithm that keeps track of the cost of the traversal thus finding the optimal cost from start to goal node. It does this by maintaining a priority queue, the elements are sorted according to the current path cost from start to the current node."),"Here is a pseudocode of Dijkstra's algorithm",n.a.createElement("br",null),n.a.createElement("code",null,"def Dijkstra(start):",n.a.createElement("br",null),"\xa0\xa0pq = PriorityQueue((start, 0))",n.a.createElement("br",null),"\xa0\xa0visited = List(start)",n.a.createElement("br",null),"\xa0\xa0distance = Dictionary(start, 0)",n.a.createElement("br",null),"\xa0\xa0for all node:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0enqueue((node, infinity))",n.a.createElement("br",null),"\xa0\xa0while pq is not empty:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0current = pq.pop()",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0if current === goal:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0return current",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0visited.add(current)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0for all neighbor of current:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0if neighbor not in visited:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0distance_to_neighbor",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 = min(",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 distance[neighbor],",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 distance[current] + cost(current, distance)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 )",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0pq.update((neighbor, distance_to_neighbor))")),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("strong",null,"Uniform Cost Search.")," Uniform Cost Search is similar to Dijkstra's algorithm The difference is only that it does not have the initialisation phase or enqueuing all nodes to the priority queue. This way, it might need smaller space compared to Dijkstra's. It also maintains a priority queue like Dijkstra's algorithm and the elements are sorted according to the current path cost from start to the current node."),"Here is a pseudocode of UCS algorithm",n.a.createElement("br",null),n.a.createElement("code",null,"def UCS(start):",n.a.createElement("br",null),"\xa0\xa0pq = PriorityQueue((start, 0))",n.a.createElement("br",null),"\xa0\xa0visited = List(start)",n.a.createElement("br",null),"\xa0\xa0distance = Dictionary(start, 0)",n.a.createElement("br",null),"\xa0\xa0while pq is not empty:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0current = pq.pop()",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0if current === goal:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0return current",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0visited.add(current)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0for all neighbor of current:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0if neighbor not in visited:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if neighbor in pq:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0distance_to_neighbor",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 = min(",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 distance[neighbor],",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 distance[current] + cost(current, distance)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 )",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0else:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0pq.add(neighbor)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0distance_to_neighbor",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 = distance[current] + cost(current, distance)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0",n.a.createElement("br",null))),n.a.createElement("h6",null,"Informed Search"),"Algorithm which falls under uninformed search includes A* search and Greedy-best-first-search. Both are actually a variant of UCS. In informed searches, there is a notion of a heuristic function,",n.a.createElement("pre",null,"h(n)"),", which indicates how far the node n to the goal node is.",n.a.createElement("br",null),n.a.createElement("br",null),"For simplicity, we use Manhattan distance from current node to goal node as our heuristic function.",n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("strong",null,"A* Search.")," A* Search is similar to UCS algorithm The difference is only the function to prioritise the elements in the priority queue. In A* search, the function used to prioritise the elements is ",n.a.createElement("pre",null,"f(n) = distance(n) + h(n)"),"."),"Here is a pseudocode of A* algorithm",n.a.createElement("br",null),n.a.createElement("code",null,"def A*(start):",n.a.createElement("br",null),"\xa0\xa0f = Dictionary(start, h(start))",n.a.createElement("br",null),"\xa0\xa0pq = PriorityQueue((start, f[start]))",n.a.createElement("br",null),"\xa0\xa0visited = List(start)",n.a.createElement("br",null),"\xa0\xa0distance = Dictionary(start, 0)",n.a.createElement("br",null),"\xa0\xa0while pq is not empty:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0current = pq.pop()",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0if current === goal:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0return current",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0visited.add(current)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0for all neighbor of current:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0if neighbor not in visited:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if neighbor in pq:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0distance_to_neighbor",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 = min(",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 distance[neighbor],",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 distance[current] + cost(current, distance)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 )",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0f[neighbor]",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 = distance_to_neighbor + h(neighbor)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0else:",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0pq.add(neighbor)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0distance_to_neighbor",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 = distance[current] + cost(current, distance)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0f[neighbor]",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 = distance_to_neighbor + h(neighbor)",n.a.createElement("br",null),"\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0",n.a.createElement("br",null))),n.a.createElement("ul",null,n.a.createElement("li",null,n.a.createElement("strong",null,"Greedy-Best-First Search.")," Greedy-Best-First Search is another variant of UCS algorithm. The difference is only the function to prioritise the elements in the priority queue. In Greedy-Best-First Search, the function used to prioritise the elements is simply ",n.a.createElement("pre",null,"h(n)"),".")),n.a.createElement("br",null))))}var d=r(14),h=r(16),m=r(17),g=r(9),f=r(18),b=r(19),p=(r(44),function(e){Object(b.a)(r,e);var t=Object(f.a)(r);function r(){return Object(h.a)(this,r),t.apply(this,arguments)}return Object(m.a)(r,[{key:"getAdditionalGridProps",value:function(){var e=this.props,t=e.isWallGrid,r=e.isStartGrid,a=e.isEndGrid;return t?"grid-wall":r?"grid-start":a?"grid-end":"white"}},{key:"render",value:function(){var e=this;return n.a.createElement("td",{id:"grid-".concat(this.props.row,"-").concat(this.props.col),className:"grid ".concat(this.getAdditionalGridProps()),onMouseDown:function(){return e.props.onMouseDown(e.props.row,e.props.col)},onMouseUp:function(){return e.props.onMouseUp(e.props.row,e.props.col)},onMouseEnter:function(){return e.props.onMouseEnter(e.props.row,e.props.col)},onMouseLeave:function(){return e.props.onMouseLeave(e.props.row,e.props.col)}})}}]),r}(a.Component)),E=r(8);function v(e){return{row:e.row,col:e.col,isVisited:e.isVisited,isWallGrid:e.isWallGrid,previousGrid:e.previousGrid,fValue:0,gValue:0,hValue:0}}function w(e){return G.apply(void 0,Object(E.a)(function(e){for(var t=[],r=null,a=null,n=0;n<e.length;n++){for(var l=[],i=0;i<e[0].length;i++){var o=e[n][i],s=v(o);l.push(s),o.isStartGrid&&(r=s),o.isEndGrid&&(a=s)}t.push(l)}return[r,a,t]}(e)))}function G(e,t,r){var a=[],n=[],l=[];for(n.push(e);n.length>0;){for(var i=0,o=0;o<n.length;o++)(n[o].fValue<n[i].fValue||(n[o].fValue=n[i].fValue)&&n[o].hValue<n[i].hValue)&&(i=o);var s=n[i];if(a.push(s),s.row===t.row&&s.col===t.col)return[a,y(t)];var u=n.indexOf(s);u>-1&&n.splice(u,1),l.push(s);for(var c=S(s,r,l),d=0;d<c.length;d++){var h=c[d],m=s.gValue+1,g=!1;k(h,n)?m<h.gValue&&(g=!0):(h.hValue=Math.abs(h.row-t.row)+Math.abs(h.col-t.col),g=!0,n.push(h)),g&&(h.gValue=m,h.fValue=h.gValue+h.hValue,h.previousGrid=s)}}return[[],[]]}function y(e){for(var t=[],r=e;r.previousGrid;)t.unshift(r),r=r.previousGrid;return t}function S(e,t,r){var a=e.row<t.length-1?t[e.row+1][e.col]:null;return[e.col<t[0].length-1?t[e.row][e.col+1]:null,a,e.col>0?t[e.row][e.col-1]:null,e.row>0?t[e.row-1][e.col]:null].filter((function(e){return null!==e&&!e.isWallGrid&&!k(e,r)}))}function k(e,t){return t.some((function(t){return t.row===e.row&&t.col===e.col}))}function V(e){return{row:e.row,col:e.col,isVisited:e.isVisited,isWallGrid:e.isWallGrid,previousGrid:e.previousGrid,hValue:0}}function D(e){return j.apply(void 0,Object(E.a)(function(e){for(var t=[],r=null,a=null,n=0;n<e.length;n++){for(var l=[],i=0;i<e[0].length;i++){var o=e[n][i],s=V(o);l.push(s),o.isStartGrid&&(r=s),o.isEndGrid&&(a=s)}t.push(l)}return[r,a,t]}(e)))}function j(e,t,r){var a=[],n=[],l=[];for(n.push(e);n.length>0;){for(var i=0,o=0;o<n.length;o++)n[o].hValue<n[i].hValue&&(i=o);var s=n[i];if(a.push(s),s.row===t.row&&s.col===t.col)return[l,M(t)];var u=n.indexOf(s);u>-1&&n.splice(u,1),l.push(s);for(var c=W(s,r,l),d=0;d<c.length;d++){var h=c[d];h.hValue=Math.abs(h.row-t.row)+Math.abs(h.col-t.col),n.push(h),h.previousGrid=s}}return[[],[]]}function M(e){for(var t=[],r=e;r.previousGrid;)console.log(r),console.log(r.previousGrid),t.unshift(r),r=r.previousGrid;return t}function W(e,t,r){var a=e.row<t.length-1?t[e.row+1][e.col]:null;return[e.col<t[0].length-1?t[e.row][e.col+1]:null,a,e.col>0?t[e.row][e.col-1]:null,e.row>0?t[e.row-1][e.col]:null].filter((function(e){return null!==e&&!e.isWallGrid&&!function(e,t){return t.some((function(t){return t.row===e.row&&t.col===e.col}))}(e,r)}))}var A=r(23);function B(e){return{row:e.row,col:e.col,distance:1/0,isVisited:e.isVisited,isWallGrid:e.isWallGrid,previousGrid:e.previousGrid}}function N(e){return O.apply(void 0,Object(E.a)(function(e){for(var t=[],r=null,a=null,n=0;n<e.length;n++){for(var l=[],i=0;i<e[0].length;i++){var o=e[n][i],s=B(o);l.push(s),o.isStartGrid&&(r=s),o.isEndGrid&&(a=s)}t.push(l)}return[r,a,t]}(e)))}function O(e,t,r){var a=r.length*r[0].length,n=[],l=function(e){var t,r=[],a=Object(A.a)(e);try{for(a.s();!(t=a.n()).done;){var n,l=t.value,i=Object(A.a)(l);try{for(i.s();!(n=i.n()).done;){var o=n.value;o.isVisited||r.push(o)}}catch(s){i.e(s)}finally{i.f()}}}catch(s){a.e(s)}finally{a.f()}return r}(r);for(e.distance=0;n.length!==a;){C(l);var i=l.shift();if(!i.isWallGrid){if(i.distance===1/0){var o=[];return[n,o]}if(n.push(i),i.isVisited=!0,T(i,r),i===t)return[n,o=q(t)]}}return[n,o=[]]}function q(e){for(var t=[],r=e;r;)t.unshift(r),r=r.previousGrid;return t}function C(e){e.sort((function(e,t){return e.distance-t.distance}))}function T(e,t){var r=function(e,t){var r=e.row<t.length-1?t[e.row+1][e.col]:null,a=e.col<t[0].length-1?t[e.row][e.col+1]:null,n=e.col>0?t[e.row][e.col-1]:null;return[e.row>0?t[e.row-1][e.col]:null,a,r,n].filter((function(e){return null!==e&&!e.isVisited&&!e.isWallGrid}))}(e,t);return function(e,t){e.map((function(e){null!==e&&(e.distance=e.distance>t.distance+1?t.distance+1:e.distance,e.isVisited=!0,e.previousGrid=t)}))}(r,e),r}function z(e){return{row:e.row,col:e.col,isVisited:e.isVisited,isWallGrid:e.isWallGrid,previousGrid:e.previousGrid}}function F(e){return I.apply(void 0,Object(E.a)(function(e){for(var t=[],r=null,a=null,n=0;n<e.length;n++){for(var l=[],i=0;i<e[0].length;i++){var o=e[n][i],s=z(o);l.push(s),o.isStartGrid&&(r=s),o.isEndGrid&&(a=s)}t.push(l)}return[r,a,t]}(e)))}function I(e,t,r){var a=[],n=[e];for(e.distance=0;0!==n.length;){var l=n.shift();if(!l.isWallGrid&&(a.push(l),l.isVisited=!0,L(l,r,n),l===t))return[a,U(t)]}return[a,U(t)]}function U(e){for(var t=[],r=e;r;)t.unshift(r),r=r.previousGrid;return t}function L(e,t,r){var a=function(e,t){var r=e.row<t.length-1?t[e.row+1][e.col]:null,a=e.col<t[0].length-1?t[e.row][e.col+1]:null,n=e.col>0?t[e.row][e.col-1]:null;return[e.row>0?t[e.row-1][e.col]:null,a,r,n].filter((function(e){return null!==e&&!e.isVisited&&!e.isWallGrid}))}(e,t);return function(e,t,r){e.map((function(e){null!==e&&(e.isVisited=!0,e.previousGrid=t,r.push(e))}))}(a,e,r),a}var P=r(62),_=r(61);r(45);function x(){return n.a.createElement("div",{className:"info-bar"},n.a.createElement(_.a,{className:"startGridBadge"},"Drag the yellow grid to set start position"),n.a.createElement(_.a,{className:"endGridBadge"},"Drag the orange grid to set end position"),n.a.createElement(_.a,{className:"wallGridBadge"},"Drag over the board to draw wall grids"),n.a.createElement(_.a,{className:"exploredGridBadge"},"Grids explored but not in the path to goal"))}r(46);var R=["A* Search","BFS","Djikstra's Algorithm","Greedy Best First Search"],H=function(e){Object(b.a)(r,e);var t=Object(f.a)(r);function r(e){var a;return Object(h.a)(this,r),(a=t.call(this,e)).header=function(){return n.a.createElement(o.a,{className:"grids-header"},n.a.createElement("label",{htmlFor:"module-credit"},"Algorithm"),n.a.createElement("select",{className:"form-control",value:a.state.algo,onChange:function(e){return a.setState({algo:e.target.value})}},R.map((function(e){return n.a.createElement("option",{key:e,value:e},e)}))),n.a.createElement(P.a,{onClick:a.visualizeAlgo,disabled:!a.state.buttonsEnabled},"Visualize!"))},a.state={rowSize:17,colSize:50,startRow:8,startCol:12,endRow:8,endCol:38,grids:[],mousePressed:!1,buttonDragged:null,algo:"A* Search",buttonsEnabled:!0,pureGrid:!0},a.handleMouseDown=a.handleMouseDown.bind(Object(g.a)(a)),a.handleMouseEnter=a.handleMouseEnter.bind(Object(g.a)(a)),a.handleMouseUp=a.handleMouseUp.bind(Object(g.a)(a)),a.handleMouseLeave=a.handleMouseLeave.bind(Object(g.a)(a)),a.visualizeAlgo=a.visualizeAlgo.bind(Object(g.a)(a)),a}return Object(m.a)(r,[{key:"componentDidMount",value:function(){this.setState({grids:this.setInitialGrids()})}},{key:"initialGrid",value:function(e,t){return{row:e,col:t,isVisited:!1,isWallGrid:!1,isStartGrid:this.isStartGrid(e,t),isEndGrid:this.isEndGrid(e,t),previousGrid:null}}},{key:"setInitialGrids",value:function(){for(var e=[],t=0;t<this.state.rowSize;t++){for(var r=[],a=0;a<this.state.colSize;a++)r.push(this.initialGrid(t,a));e.push(r)}return e}},{key:"isStartGrid",value:function(e,t){return e===this.state.startRow&&t===this.state.startCol}},{key:"isEndGrid",value:function(e,t){return e===this.state.endRow&&t===this.state.endCol}},{key:"toggleWallGrid",value:function(e,t){this.setState((function(r){var a=r.grids.slice(),n=a[e][t],l=Object.assign({},n,{isWallGrid:!n.isWallGrid});return a[e][t]=l,{grids:a,mousePressed:!0}}))}},{key:"toggleStartEndPosition",value:function(e,t){var r=this;this.state.pureGrid||this.resetColor(),this.setState((function(a){var n=a.grids.slice(),l=n[e][t];if("start"===r.state.buttonDragged){var i=Object.assign({},l,{isStartGrid:!l.isStartGrid,isWallGrid:!1});return n[e][t]=i,{grids:n,startRow:e,startCol:t}}var o=Object.assign({},l,{isEndGrid:!l.isEndGrid,isWallGrid:!1});return n[e][t]=o,{grids:n,endRow:e,endCol:t}}))}},{key:"handleMouseDown",value:function(e,t){this.state.buttonsEnabled&&(this.isStartGrid(e,t)?this.setState({buttonDragged:"start",mousePressed:!0}):this.isEndGrid(e,t)?this.setState({buttonDragged:"end",mousePressed:!0}):this.toggleWallGrid(e,t))}},{key:"handleMouseEnter",value:function(e,t){if(this.state.buttonsEnabled)if(this.state.buttonDragged)this.toggleStartEndPosition(e,t);else if(this.state.mousePressed){if(this.isStartGrid(e,t)||this.isEndGrid(e,t))return;this.toggleWallGrid(e,t)}}},{key:"handleMouseLeave",value:function(e,t){this.state.buttonsEnabled&&this.state.buttonDragged&&this.toggleStartEndPosition(e,t)}},{key:"handleMouseUp",value:function(){this.state.buttonsEnabled&&this.setState({mousePressed:!1,buttonDragged:null})}},{key:"toggleButtonsEnabled",value:function(){this.state.buttonsEnabled?this.setState({buttonsEnabled:!1}):this.setState({buttonsEnabled:!0})}},{key:"resetColor",value:function(){for(var e=0;e<this.state.rowSize;e++)for(var t=0;t<this.state.colSize;t++)if(!(e===this.state.startRow&&t===this.state.startCol||e===this.state.endRow&&t===this.state.endCol)){var r=this.state.grids[e][t];r.isWallGrid||(document.getElementById("grid-".concat(r.row,"-").concat(r.col)).className="grid")}}},{key:"visualizeAlgo",value:function(){var e=this;this.state.pureGrid||this.resetColor(),this.setState({pureGrid:!1}),this.toggleButtonsEnabled();var t=null,r=null;switch(this.state.algo){case"Djikstra's Algorithm":var a=N(this.state.grids),n=Object(d.a)(a,2);t=n[0],r=n[1];break;case"BFS":var l=F(this.state.grids),i=Object(d.a)(l,2);t=i[0],r=i[1];break;case"A* Search":var o=w(this.state.grids),s=Object(d.a)(o,2);t=s[0],r=s[1];break;case"Greedy Best First Search":var u=D(this.state.grids),c=Object(d.a)(u,2);t=c[0],r=c[1]}t.map((function(a,n){n===t.length-1&&setTimeout((function(){e.visualizePath(r)}),25*t.length),setTimeout((function(){document.getElementById("grid-".concat(a.row,"-").concat(a.col)).className="grid grid-visited",e.setStartEndGridClassName(a)}),20*n)})),setTimeout((function(){e.toggleButtonsEnabled()}),20*t.length+20*r.length+50)}},{key:"setStartEndGridClassName",value:function(e){this.isStartGrid(e.row,e.col)?document.getElementById("grid-".concat(e.row,"-").concat(e.col)).className="grid grid-start":this.isEndGrid(e.row,e.col)&&(document.getElementById("grid-".concat(e.row,"-").concat(e.col)).className="grid grid-end")}},{key:"visualizePath",value:function(e){var t=this;e.map((function(e,r){setTimeout((function(){document.getElementById("grid-".concat(e.row,"-").concat(e.col)).className="grid grid-shortest-path",t.setStartEndGridClassName(e)}),20*r)}))}},{key:"render",value:function(){var e=this;return n.a.createElement("div",null,this.header(),n.a.createElement(x,null),n.a.createElement("table",null,n.a.createElement("tbody",null,this.state.grids.map((function(t,r){return n.a.createElement("tr",{key:r},t.map((function(t,r){var a=t.row,l=t.col,i=t.distance,o=t.isVisited,s=t.isWallGrid,u=t.isStartGrid,c=t.isEndGrid,d=t.previousGrid;return n.a.createElement(p,{key:l-a,row:a,col:l,distance:i,isVisited:o,isWallGrid:s,isStartGrid:u,isEndGrid:c,previousGrid:d,onMouseDown:e.handleMouseDown,onMouseUp:e.handleMouseUp,onMouseEnter:e.handleMouseEnter,onMouseLeave:e.handleMouseLeave})})))})))))}}]),r}(a.Component);r(47);function Q(){return n.a.createElement(o.a,{className:"content"},n.a.createElement(s.a,null,n.a.createElement(u.a,null,n.a.createElement("h6",null,"How does the visualizer works?"),n.a.createElement("p",null),n.a.createElement("p",null,"Quite simple actually, the visualizer works just like the pseudocode that was presented in the theory page. It is implemented in JavaScript, and the result of the traversal is the path from the start to the goal node. As can be deduced from the theory page, some of them are optimal, some are not, according to the algorithm used.",n.a.createElement("br",null),n.a.createElement("br",null),"The optimal path from the start to the goal node is denoted in"," ",n.a.createElement("span",{className:"shortest-font"},"this")," color.",n.a.createElement("br",null),"Besides optimal path, we also track the nodes that are visited but are not part of the path from the start to the goal node. They are denoted in"," ",n.a.createElement("span",{className:"visited-font"},"this")," color."))))}var J=r(13),Y=r(3),Z=r(63);function K(){return n.a.createElement(J.a,null,n.a.createElement("div",null,n.a.createElement("nav",{className:"navbar navbar-expand-sm navbar-light bg-custom header-bar"},n.a.createElement("button",{className:"navbar-toggler",type:"button","data-toggle":"collapse","data-target":"#navbarNav","aria-controls":"navbarNav","aria-expanded":"false","aria-label":"Toggle navigation"},n.a.createElement("span",{className:"navbar-toggler-icon"})),n.a.createElement("div",{className:"collapse navbar-collapse",id:"navbarNav"},n.a.createElement("ul",{className:"navbar-nav"},n.a.createElement("li",{className:"nav-item active"},n.a.createElement(Z.a.Link,{as:J.b,exact:!0,to:"/path-visualization",activeStyle:{fontWeight:"bold",color:"black"}},"PATH VISUALIZER")),n.a.createElement("li",{className:"nav-item"},n.a.createElement(Z.a.Link,{as:J.b,exact:!0,to:"/path-visualization/theory",activeStyle:{fontWeight:"bold",color:"black"}},"GRAPH TRAVERSAL THEORY")),n.a.createElement("li",{className:"nav-item"},n.a.createElement(Z.a.Link,{as:J.b,exact:!0,to:"/path-visualization/traversal",activeStyle:{fontWeight:"bold",color:"black"}},"HOW THE VISUALIZER WORKS"))))),n.a.createElement(Y.c,null,n.a.createElement(Y.a,{path:"/path-visualization/theory"},n.a.createElement(c,null)),n.a.createElement(Y.a,{path:"/path-visualization/traversal"},n.a.createElement(Q,null)),n.a.createElement(Y.a,{path:"/path-visualization"},n.a.createElement(H,null)))))}r(56),Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));i.a.render(n.a.createElement(K,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()})).catch((function(e){console.error(e.message)}))}},[[36,1,2]]]);
//# sourceMappingURL=main.0a12bf4d.chunk.js.map