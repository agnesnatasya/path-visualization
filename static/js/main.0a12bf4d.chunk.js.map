{"version":3,"sources":["components/Theory.js","components/Grid.js","algorithms/AStar.js","algorithms/GreedyBestFirst.js","algorithms/Djikstra.js","algorithms/BFS.js","components/InfoBar.js","components/Grids.js","components/Traversal.js","App.js","serviceWorker.js","index.js"],"names":["Theory","Container","className","Row","Col","Grid","this","props","isWallGrid","isStartGrid","isEndGrid","id","row","col","getAdditionalGridProps","onMouseDown","onMouseUp","onMouseEnter","onMouseLeave","Component","initialGrid","originalGrid","isVisited","previousGrid","fValue","gValue","hValue","astar","allGrids","astarImplementation","initialGrids","startGrid","endGrid","length","currentRow","modifiedGrid","push","initializeGrids","visitedGridsInOrder","openList","closedList","lowestFOrH","i","currentGrid","getShortestPath","indexCurrentGrid","indexOf","splice","neighbors","getNeighborsOfGrid","neighbor","currentG","isBestG","isPartOfArray","Math","abs","shortestPath","unshift","grid","neighborDown","filter","gridsList","some","item","greedyBestFirst","greedyBestFirstImplementation","lowestH","console","log","distance","Infinity","djikstra","djikstraImplementation","totalGrids","allNodes","grids","getAllGrids","sortGridsByDistance","shift","relaxDistance","sort","A","B","neighborRight","neighborLeft","map","updateNeighborsProperties","bfs","bfsImplementation","queue","updateNeighborsAndQueue","InfoBar","Badge","algoChoices","Grids","header","htmlFor","value","state","algo","onChange","e","setState","target","key","Button","onClick","visualizeAlgo","disabled","buttonsEnabled","rowSize","colSize","startRow","startCol","endRow","endCol","mousePressed","buttonDragged","pureGrid","handleMouseDown","bind","handleMouseEnter","handleMouseUp","handleMouseLeave","setInitialGrids","prevState","newGrids","slice","oldGrid","newGrid","Object","assign","resetColor","toggleWallGrid","toggleStartEndPosition","document","getElementById","toggleButtonsEnabled","shortestPathGrids","index","setTimeout","visualizePath","setStartEndGridClassName","gridsRow","rowIndex","gridsCol","colIndex","Traversal","App","type","data-toggle","data-target","aria-controls","aria-expanded","aria-label","Nav","Link","as","NavLink","exact","to","activeStyle","fontWeight","color","path","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.0a12bf4d.chunk.js","sourcesContent":["import React from \"react\";\nimport { Row, Col, Container } from \"react-bootstrap\";\nimport \"./Theory.css\";\n\nexport function Theory() {\n  return (\n    <Container className=\"content\">\n      <Row>\n        <Col>\n          <h6>What is graph traversal?</h6>\n          <strong>Graph traversal</strong> is the process of visiting vertices\n          in a graph, through the edges. In this visualizer, we depict a single\n          source and single goal node, thus the goal is to reach the goal node\n          from the start node. There are other graph traversal which involves\n          multiple starting or goal node, but it is not discussed here. <br />\n          There are two types of graph traversal:\n          <ul>\n            <li>\n              <b>Uninformed search</b>. In an uninformed search, the algorithm\n              does not have any idea about how far the current node is to the\n              goal node. Thus, it takes decision according to other known\n              informations, such as the distance from the start node to a goal\n              node.\n            </li>\n            <li>\n              <b>Informed search</b>. In an informed search, the algorithm have\n              information about how far the current node to the goal node is.\n              Thus, it could make decision acccording to this information.\n              Intuitively, you would want to explore nodes that are nearer to\n              the goal node.\n            </li>\n          </ul>\n          <h6>\n            Are the grids in the visualizer a graph? <br />\n          </h6>\n          Yes, the grids represents a graph. Though graph is usually represented\n          in a more disordered way, the grids in the visualizer is also a graph.\n          Every grid in the graph is connected to either 2 or 3 or 4 adjacent\n          grids. The graph is undirected.\n          <br />\n          <h6>Uninformed Search</h6>\n          Algorithm which falls under uninformed search includes Breadth-First\n          Search (BFS), Depth-First Search (DFS), Uniform-Cost Search (UCS),\n          Dijkstra's Algorithm.\n          <br />\n          <br />\n          <ul>\n            <li>\n              <strong>Breadth-First Search.</strong> The idea of BFS is from a\n              single node, traverse all of its neighbors. After done, traverse\n              the neighbors of neighbors. Thus, it is breadth-first, it traverse\n              all nodes which are at a current layer before moving on to the\n              next layer of nodes.\n            </li>\n            Here is a pseudocode of BFS algorithm\n            <br></br>\n            <code>\n              def BFS(start):\n              <br />\n              &nbsp;&nbsp;queue = Queue(start)\n              <br />\n              &nbsp;&nbsp;visited = List(start)\n              <br />\n              &nbsp;&nbsp;while queue is not empty:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;current = queue.pop()\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;for all neighbor of current:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if neighbor === goal:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return neighbor\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if neighbor not in\n              visited:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(neighbor)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.add(neighbor)\n            </code>\n          </ul>\n          <ul>\n            <li>\n              <strong>Depth-First Search.</strong> The idea of DFS is from a\n              single node, explore its first neighbor. Then explore the first\n              neighbor of this first neighbor and so on until it reaches a\n              dead-end. After that, explore the second neighbor, and so on. The\n              implementation is very similar to BFS with a slight modification\n              of the data structure.\n            </li>\n            Here is a pseudocode of DFS algorithm\n            <br></br>\n            <code>\n              def DFS(start):\n              <br />\n              &nbsp;&nbsp;stack = Stack(start)\n              <br />\n              &nbsp;&nbsp;visited = List(start)\n              <br />\n              &nbsp;&nbsp;while stack is not empty:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;current = queue.pop()\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;for all neighbor of current:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if neighbor === goal:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return neighbor\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if neighbor not in\n              visited:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visited.add(neighbor)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.add(neighbor)\n            </code>\n          </ul>\n          <ul>\n            <li>\n              <strong>Dijkstra's Algorithm.</strong> Both BFS and DFS above does\n              not keep track of path cost. Thus, the path that it chooses to\n              reach the goal node might not be the cheapest, or the optimal.\n              Dijkstra's Algorithm is an algorithm that keeps track of the cost\n              of the traversal thus finding the optimal cost from start to goal\n              node. It does this by maintaining a priority queue, the elements\n              are sorted according to the current path cost from start to the\n              current node.\n            </li>\n            Here is a pseudocode of Dijkstra's algorithm\n            <br></br>\n            <code>\n              def Dijkstra(start):\n              <br />\n              &nbsp;&nbsp;pq = PriorityQueue((start, 0))\n              <br />\n              &nbsp;&nbsp;visited = List(start)\n              <br />\n              &nbsp;&nbsp;distance = Dictionary(start, 0)\n              <br />\n              &nbsp;&nbsp;for all node:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;enqueue((node, infinity))\n              <br />\n              &nbsp;&nbsp;while pq is not empty:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;current = pq.pop()\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;if current === goal:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return current\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;visited.add(current)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;for all neighbor of current:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if neighbor not in visited:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_to_neighbor\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = min(\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              distance[neighbor],\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              distance[current] + cost(current, distance)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pq.update((neighbor,\n              distance_to_neighbor))\n            </code>\n          </ul>\n          <ul>\n            <li>\n              <strong>Uniform Cost Search.</strong> Uniform Cost Search is\n              similar to Dijkstra's algorithm The difference is only that it\n              does not have the initialisation phase or enqueuing all nodes to\n              the priority queue. This way, it might need smaller space compared\n              to Dijkstra's. It also maintains a priority queue like Dijkstra's\n              algorithm and the elements are sorted according to the current\n              path cost from start to the current node.\n            </li>\n            Here is a pseudocode of UCS algorithm\n            <br></br>\n            <code>\n              def UCS(start):\n              <br />\n              &nbsp;&nbsp;pq = PriorityQueue((start, 0))\n              <br />\n              &nbsp;&nbsp;visited = List(start)\n              <br />\n              &nbsp;&nbsp;distance = Dictionary(start, 0)\n              <br />\n              &nbsp;&nbsp;while pq is not empty:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;current = pq.pop()\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;if current === goal:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return current\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;visited.add(current)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;for all neighbor of current:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if neighbor not in visited:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if neighbor in pq:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_to_neighbor\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              = min(\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              distance[neighbor],\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              distance[current] + cost(current, distance)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              )\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pq.add(neighbor)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_to_neighbor\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              = distance[current] + cost(current, distance)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              <br />\n            </code>\n          </ul>\n          <h6>Informed Search</h6>\n          Algorithm which falls under uninformed search includes A* search and\n          Greedy-best-first-search. Both are actually a variant of UCS. In\n          informed searches, there is a notion of a heuristic function,\n          <pre>h(n)</pre>, which indicates how far the node n to the goal node\n          is.\n          <br />\n          <br />\n          For simplicity, we use Manhattan distance from current node to goal\n          node as our heuristic function.\n          <ul>\n            <li>\n              <strong>A* Search.</strong> A* Search is similar to UCS algorithm\n              The difference is only the function to prioritise the elements in\n              the priority queue. In A* search, the function used to prioritise\n              the elements is <pre>f(n) = distance(n) + h(n)</pre>.\n            </li>\n            Here is a pseudocode of A* algorithm\n            <br></br>\n            <code>\n              def A*(start):\n              <br />\n              &nbsp;&nbsp;f = Dictionary(start, h(start))\n              <br />\n              &nbsp;&nbsp;pq = PriorityQueue((start, f[start]))\n              <br />\n              &nbsp;&nbsp;visited = List(start)\n              <br />\n              &nbsp;&nbsp;distance = Dictionary(start, 0)\n              <br />\n              &nbsp;&nbsp;while pq is not empty:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;current = pq.pop()\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;if current === goal:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return current\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;visited.add(current)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;for all neighbor of current:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if neighbor not in visited:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if neighbor in pq:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_to_neighbor\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              = min(\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              distance[neighbor],\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              distance[current] + cost(current, distance)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              )\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f[neighbor]\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              = distance_to_neighbor + h(neighbor)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pq.add(neighbor)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance_to_neighbor\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              = distance[current] + cost(current, distance)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f[neighbor]\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              = distance_to_neighbor + h(neighbor)\n              <br />\n              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n              <br />\n            </code>\n          </ul>\n          <ul>\n            <li>\n              <strong>Greedy-Best-First Search.</strong> Greedy-Best-First\n              Search is another variant of UCS algorithm. The difference is only\n              the function to prioritise the elements in the priority queue. In\n              Greedy-Best-First Search, the function used to prioritise the\n              elements is simply <pre>h(n)</pre>.\n            </li>\n          </ul>\n          <br />\n        </Col>\n      </Row>\n    </Container>\n  );\n}\n","import React, { Component } from 'react';\n\nimport './Grid.css';\n\nexport default class Grid extends Component {\n\n  /**\n   * Determine additional properties of the grid that will affect its background color.\n   */\n  getAdditionalGridProps() {\n    var { isWallGrid, isStartGrid, isEndGrid } = this.props;\n    return isWallGrid ? 'grid-wall' : isStartGrid ? 'grid-start' : isEndGrid? 'grid-end': 'white'\n  }\n\n  render() {\n    return (\n      <td\n        id={`grid-${this.props.row}-${ this.props.col}`}\n        className={`grid ${this.getAdditionalGridProps()}`}\n        onMouseDown={() => this.props.onMouseDown(this.props.row, this.props.col)}\n        onMouseUp={() => this.props.onMouseUp(this.props.row, this.props.col)}\n        onMouseEnter={() => this.props.onMouseEnter(this.props.row, this.props.col)}\n        onMouseLeave={() => this.props.onMouseLeave(this.props.row, this.props.col)}\n      >\n      </td>\n    );\n  }\n}","function initializeGrids(allGrids) {\n  let initialGrids = [];\n  let startGrid = null;\n  let endGrid = null;\n  for (let row = 0; row < allGrids.length; row++) {\n    let currentRow = [];\n    for (let col = 0; col < allGrids[0].length; col++) {\n      const originalGrid = allGrids[row][col];\n      const modifiedGrid = initialGrid(originalGrid);\n      currentRow.push(modifiedGrid);\n      if (originalGrid.isStartGrid) startGrid = modifiedGrid;\n      if (originalGrid.isEndGrid) endGrid = modifiedGrid;\n    }\n    initialGrids.push(currentRow);\n  }\n  return [startGrid, endGrid, initialGrids];\n}\n\n\nfunction initialGrid(originalGrid) {\n  var {row, col, isVisited, isWallGrid, previousGrid} = originalGrid;\n  return {\n    row: row,\n    col: col,\n    isVisited: isVisited,\n    isWallGrid: isWallGrid,\n    previousGrid: previousGrid,\n    fValue: 0,\n    gValue: 0,\n    hValue: 0,\n  }\n}\n\nexport function astar(allGrids) {\n  return astarImplementation(...initializeGrids(allGrids));\n}\n\nfunction astarImplementation(startGrid, endGrid, allGrids) {\n  var visitedGridsInOrder = []\n  var openList = [];\n  var closedList = [];\n  openList.push(startGrid);\n\n  while (openList.length > 0) {\n    let lowestFOrH = 0;\n    for (let i = 0; i < openList.length; i++) {\n      if (openList[i].fValue < openList[lowestFOrH].fValue) {\n        lowestFOrH = i;\n      } else if (openList[i].fValue = openList[lowestFOrH].fValue) {\n        if (openList[i].hValue < openList[lowestFOrH].hValue) {\n          lowestFOrH = i;\n        }\n      }\n    }\n    let currentGrid = openList[lowestFOrH];\n\n    visitedGridsInOrder.push(currentGrid);\n    if (currentGrid.row === endGrid.row && currentGrid.col === endGrid.col) {\n      return [visitedGridsInOrder, getShortestPath(endGrid)]\n    }\n\n    const indexCurrentGrid = openList.indexOf(currentGrid);\n    if (indexCurrentGrid > -1) {\n      openList.splice(indexCurrentGrid, 1);\n    }\n    closedList.push(currentGrid);\n    let neighbors = getNeighborsOfGrid(currentGrid, allGrids, closedList);\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      \n      let currentG = currentGrid.gValue + 1;\n      let isBestG = false;\n\n      if (!isPartOfArray(neighbor, openList)) {\n        neighbor.hValue = Math.abs(neighbor.row - endGrid.row) + Math.abs(neighbor.col - endGrid.col);\n        isBestG = true;\n        openList.push(neighbor);\n      } else if (currentG < neighbor.gValue) {\n        isBestG = true;\n      }\n\n      if (isBestG) {\n        neighbor.gValue = currentG;\n        neighbor.fValue = neighbor.gValue + neighbor.hValue;\n        neighbor.previousGrid = currentGrid;\n      }\n    }\n  }\n  return [[], []];\n}\n\nfunction getShortestPath(endGrid) {\n  var shortestPath = [];\n  var currentGrid = endGrid;\n  while (currentGrid.previousGrid) {\n    shortestPath.unshift(currentGrid);\n    currentGrid = currentGrid.previousGrid;\n  }\n  return shortestPath;\n};\n\nfunction getNeighborsOfGrid(grid, allGrids, closedList) {\n  var neighborDown = grid.row < allGrids.length - 1 ? allGrids[grid.row + 1][grid.col] : null;\n  var neighborRight = grid.col < allGrids[0].length - 1 ? allGrids[grid.row][grid.col + 1] : null;\n  var neighborLeft = grid.col > 0 ? allGrids[grid.row][grid.col - 1] : null;\n  var neighborTop = grid.row > 0 ? allGrids[grid.row - 1][grid.col] : null;\n  return [neighborRight, neighborDown, neighborLeft, neighborTop].filter((neighbor) =>\n    neighbor !== null && (!neighbor.isWallGrid && !isPartOfArray(neighbor, closedList))\n  );\n}\n\nfunction isPartOfArray(grid, gridsList) {\n  return gridsList.some((item) => (item.row === grid.row && item.col === grid.col));\n}\n","function initializeGrids(allGrids) {\n  let initialGrids = [];\n  let startGrid = null;\n  let endGrid = null;\n  for (let row = 0; row < allGrids.length; row++) {\n    let currentRow = [];\n    for (let col = 0; col < allGrids[0].length; col++) {\n      const originalGrid = allGrids[row][col];\n      const modifiedGrid = initialGrid(originalGrid);\n      currentRow.push(modifiedGrid);\n      if (originalGrid.isStartGrid) startGrid = modifiedGrid;\n      if (originalGrid.isEndGrid) endGrid = modifiedGrid;\n    }\n    initialGrids.push(currentRow);\n  }\n  return [startGrid, endGrid, initialGrids];\n}\n\nfunction initialGrid(originalGrid) {\n  var { row, col, isVisited, isWallGrid, previousGrid } = originalGrid;\n  return {\n    row,\n    col,\n    isVisited: isVisited,\n    isWallGrid: isWallGrid,\n    previousGrid: previousGrid,\n    hValue: 0,\n  };\n}\n\nexport function greedyBestFirst(allGrids) {\n  return greedyBestFirstImplementation(...initializeGrids(allGrids));\n}\n\nexport function greedyBestFirstImplementation(startGrid, endGrid, allGrids) {\n  var visitedGridsInOrder = []\n  var openList = [];\n  var closedList = [];\n  openList.push(startGrid);\n\n  while (openList.length > 0) {\n    let lowestH = 0;\n    for (let i = 0; i < openList.length; i++) {\n      if (openList[i].hValue < openList[lowestH].hValue) {\n        lowestH = i;\n      }\n    }\n    let currentGrid = openList[lowestH];\n    visitedGridsInOrder.push(currentGrid);\n    if (currentGrid.row === endGrid.row && currentGrid.col === endGrid.col) {\n      return [closedList, getShortestPath(endGrid)]\n    }\n\n    const indexCurrentGrid = openList.indexOf(currentGrid);\n    if (indexCurrentGrid > -1) {\n      openList.splice(indexCurrentGrid, 1);\n    }\n    closedList.push(currentGrid);\n\n    let neighbors = getNeighborsOfGrid(currentGrid, allGrids, closedList);\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n      neighbor.hValue = (Math.abs(neighbor.row - endGrid.row) + Math.abs(neighbor.col - endGrid.col))\n      openList.push(neighbor);\n      neighbor.previousGrid = currentGrid;\n    }\n  }\n  return [[], []];\n}\n\nfunction getShortestPath(endGrid) {\n  var shortestPath = [];\n  var currentGrid = endGrid;\n  while (currentGrid.previousGrid) {\n    console.log(currentGrid);\n    console.log(currentGrid.previousGrid)\n    shortestPath.unshift(currentGrid);\n    currentGrid = currentGrid.previousGrid;\n  }\n  return shortestPath;\n};\n\nfunction getNeighborsOfGrid(grid, allGrids, closedList) {\n  var neighborDown = grid.row < allGrids.length - 1 ? allGrids[grid.row + 1][grid.col] : null;\n  var neighborRight = grid.col < allGrids[0].length - 1 ? allGrids[grid.row][grid.col + 1] : null;\n  var neighborLeft = grid.col > 0 ? allGrids[grid.row][grid.col - 1] : null;\n  var neighborTop = grid.row > 0 ? allGrids[grid.row - 1][grid.col] : null;\n  return [neighborRight, neighborDown, neighborLeft, neighborTop].filter((neighbor) =>\n    neighbor !== null && (!neighbor.isWallGrid && !isPartOfArray(neighbor, closedList))\n  );\n}\n\nfunction isPartOfArray(grid, gridsList) {\n  return gridsList.some((item) => (item.row === grid.row && item.col === grid.col));\n}","function initializeGrids(allGrids) {\n  let initialGrids = [];\n  let startGrid = null;\n  let endGrid = null;\n  for (let row = 0; row < allGrids.length; row++) {\n    let currentRow = [];\n    for (let col = 0; col < allGrids[0].length; col++) {\n      const originalGrid = allGrids[row][col];\n      const modifiedGrid = initialGrid(originalGrid);\n      currentRow.push(modifiedGrid);\n      if (originalGrid.isStartGrid) startGrid = modifiedGrid;\n      if (originalGrid.isEndGrid) endGrid = modifiedGrid;\n    }\n    initialGrids.push(currentRow);\n  }\n  return [startGrid, endGrid, initialGrids];\n}\n\nfunction initialGrid(originalGrid) {\n  var { row, col, isVisited, isWallGrid, previousGrid } = originalGrid;\n  return {\n    row,\n    col,\n    distance: Infinity,\n    isVisited: isVisited,\n    isWallGrid: isWallGrid,\n    previousGrid: previousGrid,\n  };\n}\n\nexport function djikstra(allGrids) {\n  return djikstraImplementation(...initializeGrids(allGrids));\n}\n\n\nfunction djikstraImplementation(startGrid, endGrid, allGrids) {\n  var totalGrids = allGrids.length * allGrids[0].length;\n  var visitedGridsInOrder = [];\n  var allNodes = getAllGrids(allGrids);\n  startGrid.distance = 0;\n  while (visitedGridsInOrder.length !== totalGrids) {\n    sortGridsByDistance(allNodes);\n    var currentGrid = allNodes.shift();\n    if (currentGrid.isWallGrid) continue;\n    if (currentGrid.distance === Infinity) {\n      var shortestPath = [];\n      return [visitedGridsInOrder, shortestPath];\n    }\n    visitedGridsInOrder.push(currentGrid);\n    currentGrid.isVisited = true;\n    \n    relaxDistance(currentGrid, allGrids);\n    if (currentGrid === endGrid) {\n      shortestPath = getShortestPath(endGrid);\n      return [visitedGridsInOrder, shortestPath];\n    }\n  }\n  shortestPath = [];\n  return [visitedGridsInOrder, shortestPath];\n}\n\nfunction getAllGrids(allGrids) {\n  const grids = [];\n  for (const row of allGrids) {\n    for (const grid of row) {\n      if (!grid.isVisited) {\n        grids.push(grid);\n      }\n    }\n  }\n  return grids;\n}\n\nfunction getShortestPath(endGrid) {\n  var shortestPath = [];\n  var currentGrid = endGrid;\n  while (currentGrid) {\n    shortestPath.unshift(currentGrid);\n    currentGrid = currentGrid.previousGrid;\n  }\n  return shortestPath;\n}\n\nfunction sortGridsByDistance(allNodes) {\n  allNodes.sort((A, B) => A.distance - B.distance);\n}\n\nfunction relaxDistance(currentGrid, allGrids) {\n  var neighbors = getNeighborsOfGrid(currentGrid, allGrids);\n  updateNeighborsProperties(neighbors, currentGrid);\n  return neighbors;\n}\n\nfunction getNeighborsOfGrid(grid, allGrids) {\n  var neighborDown = grid.row < allGrids.length - 1 ? allGrids[grid.row + 1][grid.col]: null;\n  var neighborRight = grid.col < allGrids[0].length - 1 ? allGrids[grid.row][grid.col + 1]: null;\n  var neighborLeft = grid.col > 0 ? allGrids[grid.row][grid.col - 1] : null;\n  var neighborTop = grid.row > 0 ? allGrids[grid.row - 1][grid.col] : null;\n  return [neighborTop, neighborRight, neighborDown, neighborLeft].filter((neighbor) =>\n    neighbor !== null && (!neighbor.isVisited && !neighbor.isWallGrid)\n  );\n}\n\nfunction updateNeighborsProperties(neighbors, currentGrid) {\n  neighbors.map((neighbor) => {\n    if (neighbor !== null) {\n      neighbor.distance =\n        (neighbor.distance > currentGrid.distance + 1) ?\n          currentGrid.distance + 1\n          :\n          neighbor.distance;\n      neighbor.isVisited = true;\n      neighbor.previousGrid = currentGrid;\n    }\n  })\n}","function initializeGrids(allGrids) {\n  let initialGrids = [];\n  let startGrid = null;\n  let endGrid = null;\n  for (let row = 0; row < allGrids.length; row++) {\n    let currentRow = [];\n    for (let col = 0; col < allGrids[0].length; col++) {\n      const originalGrid = allGrids[row][col];\n      const modifiedGrid = initialGrid(originalGrid);\n      currentRow.push(modifiedGrid);\n      if (originalGrid.isStartGrid) startGrid = modifiedGrid;\n      if (originalGrid.isEndGrid) endGrid = modifiedGrid;\n    }\n    initialGrids.push(currentRow);\n  }\n  return [startGrid, endGrid, initialGrids];\n}\n\nfunction initialGrid(originalGrid) {\n  var { row, col, isVisited, isWallGrid, previousGrid } = originalGrid;\n  return {\n    row: row,\n    col: col,\n    isVisited: isVisited,\n    isWallGrid: isWallGrid,\n    previousGrid: previousGrid,\n  };\n}\n\nexport function bfs(allGrids) {\n  return bfsImplementation(...initializeGrids(allGrids));\n}\n\nfunction bfsImplementation(startGrid, endGrid, allGrids) {\n  var visitedGridsInOrder = [];\n  var queue = [startGrid];\n  startGrid.distance = 0;\n  while (queue.length !== 0) {\n    var currentGrid = queue.shift();\n    if (currentGrid.isWallGrid) continue;\n    visitedGridsInOrder.push(currentGrid);\n    currentGrid.isVisited = true;\n    updateNeighborsAndQueue(currentGrid, allGrids, queue);\n    if (currentGrid === endGrid) {\n      return [visitedGridsInOrder, getShortestPath(endGrid)];\n    }\n  }\n  return [visitedGridsInOrder, getShortestPath(endGrid)];\n}\n\nfunction getShortestPath(endGrid) {\n  var shortestPath = [];\n  var currentGrid = endGrid;\n  while (currentGrid) {\n    shortestPath.unshift(currentGrid);\n    currentGrid = currentGrid.previousGrid;\n  }\n  return shortestPath;\n}\n\nfunction updateNeighborsAndQueue(currentGrid, allGrids, queue) {\n  var neighbors = getNeighborsOfGrid(currentGrid, allGrids);\n  updateNeighborsProperties(neighbors, currentGrid, queue);\n  return neighbors;\n}\n\nfunction getNeighborsOfGrid(grid, allGrids) {\n  var neighborDown = grid.row < allGrids.length - 1 ? allGrids[grid.row + 1][grid.col] : null;\n  var neighborRight = grid.col < allGrids[0].length - 1 ? allGrids[grid.row][grid.col + 1] : null;\n  var neighborLeft = grid.col > 0 ? allGrids[grid.row][grid.col - 1] : null;\n  var neighborTop = grid.row > 0 ? allGrids[grid.row - 1][grid.col] : null;\n  return [neighborTop, neighborRight, neighborDown, neighborLeft].filter((neighbor) =>\n    neighbor !== null && (!neighbor.isVisited && !neighbor.isWallGrid)\n  );\n}\n\nfunction updateNeighborsProperties(neighbors, currentGrid, queue) {\n  neighbors.map((neighbor) => {\n    if (neighbor !== null) {\n      neighbor.isVisited = true;\n      neighbor.previousGrid = currentGrid;\n      queue.push(neighbor);\n    }\n  })\n}","import React from \"react\";\nimport { Badge } from \"react-bootstrap\";\nimport \"./InfoBar.css\";\n\nexport function InfoBar() {\n  return (\n    <div className=\"info-bar\">\n      <Badge className=\"startGridBadge\">\n        Drag the yellow grid to set start position\n      </Badge>\n      <Badge className=\"endGridBadge\">\n        Drag the orange grid to set end position\n      </Badge>\n      <Badge className=\"wallGridBadge\">\n        Drag over the board to draw wall grids\n      </Badge>\n      <Badge className=\"exploredGridBadge\">\n        Grids explored but not in the path to goal\n      </Badge>\n    </div>\n  );\n\n}\n","import React, { Component } from 'react';\nimport Grid from './Grid';\nimport { astar } from '../algorithms/AStar.js'\nimport { greedyBestFirst } from '../algorithms/GreedyBestFirst.js'\nimport { djikstra } from '../algorithms/Djikstra.js'\nimport { bfs } from '../algorithms/BFS.js'\nimport { Button, Container } from 'react-bootstrap'\nimport { InfoBar } from \"./InfoBar\";\n\nimport './Grids.css';\n\nconst algoChoices = [\n  \"A* Search\",\n  \"BFS\",\n  \"Djikstra's Algorithm\",\n  \"Greedy Best First Search\",\n]\n\nexport class Grids extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      rowSize: 17,\n      colSize: 50,\n      startRow: 8,\n      startCol: 12,\n      endRow: 8,\n      endCol: 38,\n      grids: [],\n      mousePressed: false,\n      buttonDragged: null,\n      algo: \"A* Search\",\n      buttonsEnabled: true,\n      pureGrid: true,\n    };\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.visualizeAlgo = this.visualizeAlgo.bind(this);\n  }\n\n  componentDidMount() {\n    this.setState({ grids: this.setInitialGrids() });\n  }\n\n  /**\n   * Header element to choose algorithm and render 'visualize' button\n   */\n  header = () => {\n    return (\n      <Container className=\"grids-header\">\n          <label htmlFor=\"module-credit\">Algorithm</label>\n          <select\n            className=\"form-control\"\n            value={this.state.algo}\n            onChange={(e) => this.setState({ algo: e.target.value })}\n          >\n            {algoChoices.map((item) => (\n              <option key={item} value={item}>\n                {item}\n              </option>\n            ))}\n          </select>\n          <Button\n            onClick={this.visualizeAlgo}\n            disabled={!this.state.buttonsEnabled}\n          >\n            Visualize!\n          </Button>\n      </Container>\n    );\n  }\n\n  /**\n   * Return object of the grid at this row and column number\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  initialGrid(row, col) {\n    return {\n      row: row,\n      col: col,\n      isVisited: false,\n      isWallGrid: false,\n      isStartGrid: this.isStartGrid(row, col),\n      isEndGrid: this.isEndGrid(row, col),\n      previousGrid: null,\n    };\n  }\n\n  /**\n   * Set up initial grids state\n   */\n  setInitialGrids() {\n    let initialGrids = [];\n    for (let row = 0; row < this.state.rowSize; row++) {\n      let currentRow = [];\n      for (let col = 0; col < this.state.colSize; col++) {\n        currentRow.push(this.initialGrid(row, col));\n      }\n      initialGrids.push(currentRow);\n    }\n    return initialGrids;\n  }\n\n  /**\n   * Determine whether the grid at this row and col is a start grid\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  isStartGrid(row, col) {\n    return (row === this.state.startRow) && (col === this.state.startCol);\n  }\n\n  /**\n   * Determine whether the grid at this row and col is an end grid\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  isEndGrid(row, col) {\n    return (row === this.state.endRow) && (col === this.state.endCol)\n  }\n\n  /**\n   * Toggle a grid between a wall and non-wall grid\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  toggleWallGrid(row, col) {\n    this.setState(prevState => {\n      const newGrids = prevState.grids.slice();\n      const oldGrid = newGrids[row][col];\n      const newGrid = Object.assign({}, oldGrid, { isWallGrid: !oldGrid.isWallGrid });\n      newGrids[row][col] = newGrid;\n      return ({ grids: newGrids, mousePressed: true });\n    })\n  }\n\n  /**\n   * Change position of start or end grid to the specified row and column\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  toggleStartEndPosition(row, col) {\n    if (!this.state.pureGrid) {\n      this.resetColor();\n    }\n    this.setState(prevState => {\n      const newGrids = prevState.grids.slice();\n      const oldGrid = newGrids[row][col];\n      if (this.state.buttonDragged === 'start') {\n        const newGrid = Object.assign({}, oldGrid, { isStartGrid: !oldGrid.isStartGrid, isWallGrid: false });\n        newGrids[row][col] = newGrid;\n        return ({ grids: newGrids, startRow: row, startCol: col });\n      } else {\n        const newGrid = Object.assign({}, oldGrid, { isEndGrid: !oldGrid.isEndGrid, isWallGrid: false });\n        newGrids[row][col] = newGrid;\n        return ({ grids: newGrids, endRow: row, endCol: col });\n      }\n    });\n  }\n\n  /**\n   * Handle MouseDown event at that row and column\n   * If it is a start or end grid, set mousePressed property to true, so it can be dragged later\n   * If it is a normal or wall grid, toggle wall grids\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  handleMouseDown(row, col) {\n    if (this.state.buttonsEnabled) {\n      if (this.isStartGrid(row, col)) {\n        this.setState({ buttonDragged: \"start\", mousePressed: true });\n      } else if (this.isEndGrid(row, col)) {\n        this.setState({ buttonDragged: \"end\", mousePressed: true });\n      } else {\n        this.toggleWallGrid(row, col);\n      }\n    }\n  }\n\n  /**\n   * Handle MouseEnter event at that row and column\n   * If currently the button is dragging a start or end grid,\n   * set the start or end grid position to the current position\n   * If it is pressing position on normal or wall grids, toggle wall grid property. \n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  handleMouseEnter(row, col) {\n    if (this.state.buttonsEnabled) {\n      if (this.state.buttonDragged) {\n        this.toggleStartEndPosition(row, col);\n      } else if (this.state.mousePressed) {\n        if (this.isStartGrid(row, col) || this.isEndGrid(row, col)) {\n          return;\n        }\n        this.toggleWallGrid(row, col);\n      }\n    }\n  }\n\n  /**\n   * Handle MouseLeave event at this row and column\n   * If it just leaves a start or end grid, set the previous one to normal grid\n   * @param {*} row The row number of the grid\n   * @param {*} col The col number of the grid\n   */\n  handleMouseLeave(row, col) {\n    if (this.state.buttonsEnabled) {\n      if (this.state.buttonDragged) {\n        this.toggleStartEndPosition(row, col);\n      }\n    }\n  }\n\n  /**\n   * Handle MouseUp event\n   */\n  handleMouseUp() {\n    if (this.state.buttonsEnabled) {\n      this.setState({ mousePressed: false, buttonDragged: null });\n    }\n  }\n\n  /**\n   * Toggle buttonsEnabled state\n   */\n  toggleButtonsEnabled() {\n    if (this.state.buttonsEnabled) {\n      this.setState({ buttonsEnabled: false });\n    } else {\n      this.setState({ buttonsEnabled: true });\n    }\n  }\n\n  /**\n   * Reset color of all grids to background color\n   */\n  resetColor() {\n    for (let row = 0; row < this.state.rowSize; row++) {\n      for (let col = 0; col < this.state.colSize; col++) {\n        if ((row === this.state.startRow && col === this.state.startCol) || (row === this.state.endRow && col === this.state.endCol)) continue;\n        const item = this.state.grids[row][col];\n        if (item.isWallGrid) continue;\n        document.getElementById(`grid-${item.row}-${item.col}`).className = \"grid\";\n      }\n    }\n  }\n\n  /**\n   * Algo visualization trigger\n   */\n  visualizeAlgo() {\n    if (!this.state.pureGrid) {\n      this.resetColor();\n    }\n    this.setState({pureGrid: false})\n    this.toggleButtonsEnabled();\n\n    let [visitedGridsInOrder, shortestPathGrids] = [null, null];\n    switch (this.state.algo) {\n      case \"Djikstra's Algorithm\":\n        [visitedGridsInOrder, shortestPathGrids] = djikstra(this.state.grids);\n        break;\n      case \"BFS\":\n        [visitedGridsInOrder, shortestPathGrids] = bfs(this.state.grids);\n        break;\n      case \"A* Search\":\n        [visitedGridsInOrder, shortestPathGrids] = astar(this.state.grids);\n        break;\n      case \"Greedy Best First Search\":\n        [visitedGridsInOrder, shortestPathGrids] = greedyBestFirst(\n          this.state.grids\n        );\n        break;\n    }\n\n    visitedGridsInOrder.map((item, index) => {\n      if (index === visitedGridsInOrder.length -1 ) {\n        setTimeout(() => { this.visualizePath(shortestPathGrids);\n        }, 25 * visitedGridsInOrder.length);\n      }\n      setTimeout(() => {\n        document.getElementById(`grid-${item.row}-${item.col}`).className =\n          \"grid grid-visited\";\n        this.setStartEndGridClassName(item);\n      }, 20 * index);\n    });\n\n    setTimeout(() => {\n      this.toggleButtonsEnabled();\n    }, 20 * visitedGridsInOrder.length + 20 * shortestPathGrids.length + 50);\n  }\n\n  /**\n   * Set class name to grid-start or grid-end if it is a start or end grid\n   * @param {*} item The grid item\n   */\n  setStartEndGridClassName(item) {\n    if (this.isStartGrid(item.row, item.col)) {\n      document.getElementById(`grid-${item.row}-${item.col}`).className =\n        \"grid grid-start\";\n    } else if (this.isEndGrid(item.row, item.col)) {\n      document.getElementById(`grid-${item.row}-${item.col}`).className =\n        \"grid grid-end\";\n    }\n  }\n  \n  /**\n   * Function to visualize the path\n   * @param {*} shortestPathGrids The grid array that consttitutest the path\n   */\n  visualizePath(shortestPathGrids) {\n    shortestPathGrids.map((item, index) => {\n      setTimeout(() => {\n        document.getElementById(`grid-${item.row}-${item.col}`).className =\n          \"grid grid-shortest-path\";\n        this.setStartEndGridClassName(item);\n      }, 20 * index);\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        {this.header()}\n        <InfoBar />\n        <table>\n          <tbody>\n            {this.state.grids.map((gridsRow, rowIndex) => {\n              return (\n                <tr key={rowIndex}>\n                  {gridsRow.map((gridsCol, colIndex) => {\n                    var {\n                      row,\n                      col,\n                      distance,\n                      isVisited,\n                      isWallGrid,\n                      isStartGrid,\n                      isEndGrid,\n                      previousGrid,\n                    } = gridsCol;\n                    return (\n                      <Grid\n                        key={col - row}\n                        row={row}\n                        col={col}\n                        distance={distance}\n                        isVisited={isVisited}\n                        isWallGrid={isWallGrid}\n                        isStartGrid={isStartGrid}\n                        isEndGrid={isEndGrid}\n                        previousGrid={previousGrid}\n                        onMouseDown={this.handleMouseDown}\n                        onMouseUp={this.handleMouseUp}\n                        onMouseEnter={this.handleMouseEnter}\n                        onMouseLeave={this.handleMouseLeave}\n                      />\n                    );\n                  })}\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n}","import React from \"react\";\nimport { Row, Col, Container } from \"react-bootstrap\";\nimport \"./Traversal.css\";\n\nexport function Traversal() {\n  return (\n    <Container className=\"content\">\n      <Row>\n        <Col>\n          <h6>How does the visualizer works?</h6>\n          <p></p>\n\n          <p>\n            Quite simple actually, the visualizer works just like the pseudocode\n            that was presented in the theory page. It is implemented in\n            JavaScript, and the result of the traversal is the path from the\n            start to the goal node. As can be deduced from the theory page, some\n            of them are optimal, some are not, according to the algorithm used.\n            <br /><br />\n            The optimal path from the start to the goal node is denoted in{\" \"}\n            <span className=\"shortest-font\">this</span> color.\n            <br />\n            Besides optimal path, we also track the nodes that are visited but are not\n            part of the path from the start to the goal node. They are denoted in{\" \"}\n            <span className=\"visited-font\">this</span> color.\n          </p>\n        </Col>\n      </Row>\n    </Container>\n  );\n}\n","import React from 'react';\nimport './App.css';\nimport { Theory } from \"./components/Theory\";\nimport { Grids } from \"./components/Grids\";\nimport { Traversal } from './components/Traversal';\nimport { BrowserRouter as Router, Switch, Route, NavLink } from \"react-router-dom\";\nimport { Nav } from \"react-bootstrap\";\n\nexport default function App() {\n    return (\n        <Router>\n            <div>\n                <nav className=\"navbar navbar-expand-sm navbar-light bg-custom header-bar\">\n                    <button\n                        className=\"navbar-toggler\"\n                        type=\"button\"\n                        data-toggle=\"collapse\"\n                        data-target=\"#navbarNav\"\n                        aria-controls=\"navbarNav\"\n                        aria-expanded=\"false\"\n                        aria-label=\"Toggle navigation\"\n                    >\n                        <span className=\"navbar-toggler-icon\"></span>\n                    </button>\n                    <div className=\"collapse navbar-collapse\" id=\"navbarNav\">\n                        <ul className=\"navbar-nav\">\n                            <li className=\"nav-item active\">\n                                <Nav.Link\n                                    as={NavLink}\n                                    exact\n                                    to=\"/path-visualization\"\n                                    activeStyle={{\n                                        fontWeight: \"bold\",\n                                        color: \"black\",\n                                    }}\n                                >\n                                    PATH VISUALIZER\n                                </Nav.Link>\n                            </li>\n                            <li className=\"nav-item\">\n                                <Nav.Link\n                                    as={NavLink}\n                                    exact\n                                    to=\"/path-visualization/theory\"\n                                    activeStyle={{\n                                        fontWeight: \"bold\",\n                                        color: \"black\",\n                                    }}\n                                >\n                                    GRAPH TRAVERSAL THEORY\n                                </Nav.Link>\n                            </li>\n                            <li className=\"nav-item\">\n                                <Nav.Link\n                                    as={NavLink}\n                                    exact\n                                    to=\"/path-visualization/traversal\"\n                                    activeStyle={{\n                                        fontWeight: \"bold\",\n                                        color: \"black\",\n                                    }}\n                                >\n                                    HOW THE VISUALIZER WORKS\n                                </Nav.Link>\n                            </li>\n                        </ul>\n                    </div>\n                </nav>\n\n                {/* A <Switch> looks through its children <Route>s and\n            renders the first one that matches the current URL. */}\n                <Switch>\n                    <Route path=\"/path-visualization/theory\">\n                        <Theory />\n                    </Route>\n                    <Route path=\"/path-visualization/traversal\">\n                        <Traversal />\n                    </Route>\n                    <Route path=\"/path-visualization\">\n                        <Grids />\n                    </Route>\n                </Switch>\n            </div>\n        </Router>\n    );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}